
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for Building Vitals/Building-Vitals/build/js/services-B0KkmCks.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">Building Vitals/Building-Vitals/build/js</a> services-B0KkmCks.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/2</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/2</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["js/app-core-rH6lZf1X.js","js/vendor-CFMRQ_Yt.js","js/data-vendor-DBrFxduC.js","js/echarts-vendor-xTKhTmAz.js","assets/vendor-BOltB2Hq.css","js/firebase-vendor-DFJ8_Xw5.js","js/utils-CrQ8UdBz.js","js/date-vendor-BU9txqBG.js","js/components-DaeLY-_K.js","assets/components-DgQfaczj.css"])))=&gt;i.map(i=&gt;d[i]);</span></span></span>
<span class="cstat-no" title="statement not covered" >var __defProp=Object.defineProperty,__publicField=(obj,key,value)=&gt;((obj,key,value)=&gt;key in obj?__defProp(obj,key,{enumerable:!0,configurable:!0,writable:!0,value:value}):obj[key]=value)(obj,"symbol"!=typeof key?key+"":key,value);import{E as store,Q as cloudflareWorkerClient,c as auth,_ as __vitePreload,R as getTokenService,x as db,O as createLogger,S as aceIotApiClient}from"./app-core-rH6lZf1X.js";import{g as getAuth,c as getFunctions,k as httpsCallable,l as doc,m as getDoc,u as updateDoc,x as collection,y as getDocs,s as setDoc,z as query,A as where,B as orderBy,C as addDoc,o as serverTimestamp,D as deleteDoc}from"./firebase-vendor-DFJ8_Xw5.js";import{eb as EventEmitter,m as jwtDecode,ec as decode}from"./vendor-CFMRQ_Yt.js";import{h as hasKvTags,j as enhancePointWithKvTags,b9 as API_ENDPOINTS}from"./utils-CrQ8UdBz.js";const siteTimezoneService=new class SiteTimezoneService{constructor(){__publicField(this,"cache",null)}getSiteTimezone(siteId){return this.getAllTimezones()[siteId]||null}setSiteTimezone(siteId,timezone){const timezones=this.getAllTimezones();timezones[siteId]=timezone,this.saveTimezones(timezones)}getAllTimezones(){if(this.cache)return this.cache;try{const stored=localStorage.getItem("siteTimezones");return this.cache=stored?JSON.parse(stored):{},this.cache}catch(error){return this.cache={},this.cache}}saveTimezones(timezones){try{localStorage.setItem("siteTimezones",JSON.stringify(timezones)),this.cache=timezones}catch(error){}}removeSiteTimezone(siteId){const timezones=this.getAllTimezones();delete timezones[siteId],this.saveTimezones(timezones)}clearAll(){localStorage.removeItem("siteTimezones"),this.cache={}}importTimezones(timezones){this.saveTimezones(timezones)}getSiteTimezoneWithFallback(site,userTimezone){const siteId="string"==typeof site?site:site.id;if("object"==typeof site&amp;&amp;site.timezone)return site.timezone;const storedTimezone=this.getSiteTimezone(siteId);return storedTimezone||(userTimezone||Intl.DateTimeFormat().resolvedOptions().timeZone)}migrate(){}},getSiteTimezoneWithFallback=(site,userTimezone)=&gt;siteTimezoneService.getSiteTimezoneWithFallback(site,userTimezone);class EncryptionService{constructor(){__publicField(this,"ALGORITHM","AES-GCM"),__publicField(this,"KEY_LENGTH",256),__publicField(this,"SALT_LENGTH",16),__publicField(this,"IV_LENGTH",12),__publicField(this,"TAG_LENGTH",16),__publicField(this,"ITERATIONS",1e5)}async deriveKey(userId,salt){const keyMaterial=await crypto.subtle.importKey("raw",(new TextEncoder).encode("prod-encryption-secret-please-change-this!"+userId),"PBKDF2",!1,["deriveKey"]);return crypto.subtle.deriveKey({name:"PBKDF2",salt:salt,iterations:this.ITERATIONS,hash:"SHA-256"},keyMaterial,{name:this.ALGORITHM,length:this.KEY_LENGTH},!1,["encrypt","decrypt"])}async encrypt(data,userId){try{const salt=crypto.getRandomValues(new Uint8Array(this.SALT_LENGTH)),iv=crypto.getRandomValues(new Uint8Array(this.IV_LENGTH)),key=await this.deriveKey(userId,salt),encoded=(new TextEncoder).encode(data),encrypted=await crypto.subtle.encrypt({name:this.ALGORITHM,iv:iv},key,encoded),combined=new Uint8Array(salt.length+iv.length+encrypted.byteLength);return combined.set(salt,0),combined.set(iv,salt.length),combined.set(new Uint8Array(encrypted),salt.length+iv.length),btoa(String.fromCharCode(...combined))}catch(error){throw console.error("[EncryptionService] Encryption failed:",error),new Error("Failed to encrypt data")}}async decrypt(encryptedData,userId){try{const combined=Uint8Array.from(atob(encryptedData),c=&gt;c.charCodeAt(0)),salt=combined.slice(0,this.SALT_LENGTH),iv=combined.slice(this.SALT_LENGTH,this.SALT_LENGTH+this.IV_LENGTH),encrypted=combined.slice(this.SALT_LENGTH+this.IV_LENGTH),key=await this.deriveKey(userId,salt),decrypted=await crypto.subtle.decrypt({name:this.ALGORITHM,iv:iv},key,encrypted);return(new TextDecoder).decode(decrypted)}catch(error){throw console.error("[EncryptionService] Decryption failed:",error),new Error("Failed to decrypt data")}}async hashToken(token){const encoded=(new TextEncoder).encode(token),hashBuffer=await crypto.subtle.digest("SHA-256",encoded);return Array.from(new Uint8Array(hashBuffer)).map(b=&gt;b.toString(16).padStart(2,"0")).join("")}secureCompare(a,b){if(a.length!==b.length)return!1;let result=0;for(let i=0;i&lt;a.length;i++)result|=a.charCodeAt(i)^b.charCodeAt(i);return 0===result}}const encryptionService=new EncryptionService,encryption=Object.freeze(Object.defineProperty({__proto__:null,EncryptionService:EncryptionService,encryptionService:encryptionService},Symbol.toStringTag,{value:"Module"}));const secureStorage=new class SecureStorageService{constructor(){__publicField(this,"TOKEN_KEY","aceToken_encrypted_v2"),__publicField(this,"SESSION_TOKEN_KEY","aceToken_session_v2"),__publicField(this,"userId",null)}setUserId(userId){this.userId=userId}getUserId(){var _a,_b;if(this.userId)return this.userId;const authKeys=Object.keys(localStorage).filter(key=&gt;key.startsWith("firebase:authUser:"));for(const key of authKeys)try{const authStr=localStorage.getItem(key);if(authStr){const authData=JSON.parse(authStr),users=Array.isArray(authData)?authData:Object.values(authData);for(const user of users)if(user&amp;&amp;"object"==typeof user&amp;&amp;"uid"in user&amp;&amp;user.uid)return user.uid}}catch(error){}try{const reduxState=window.__REDUX_STATE__;if(null==(_b=null==(_a=null==reduxState?void 0:reduxState.auth)?void 0:_a.firebaseUser)?void 0:_b.uid)return reduxState.auth.firebaseUser.uid}catch{}let deviceId=localStorage.getItem("device_id_fallback");return deviceId||(deviceId=`device-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,localStorage.setItem("device_id_fallback",deviceId)),deviceId}async encrypt(text){const userId=this.getUserId();return encryptionService.encrypt(text,userId)}async decrypt(ciphertext){try{if(this.isValidTokenFormat(ciphertext))return ciphertext;const userId=this.getUserId();return await encryptionService.decrypt(ciphertext,userId)||""}catch(_error){return this.isValidTokenFormat(ciphertext)?ciphertext:""}}async setAceToken(token,persistent=!0){if(!token)return void this.clearAceToken();this.clearAceToken(),localStorage.removeItem("aceToken_encrypted"),sessionStorage.removeItem("aceToken_session");const encryptedToken=await this.encrypt(token);persistent?(localStorage.setItem(this.TOKEN_KEY,encryptedToken),sessionStorage.removeItem(this.SESSION_TOKEN_KEY)):(sessionStorage.setItem(this.SESSION_TOKEN_KEY,encryptedToken),localStorage.removeItem(this.TOKEN_KEY))}async getAceToken(){const sessionToken=sessionStorage.getItem(this.SESSION_TOKEN_KEY);if(sessionToken){return await this.decrypt(sessionToken)||null}const persistentToken=localStorage.getItem(this.TOKEN_KEY);if(persistentToken){return await this.decrypt(persistentToken)||null}const oldToken=localStorage.getItem("aceToken_encrypted")||sessionStorage.getItem("aceToken_session");return oldToken&amp;&amp;this.isValidTokenFormat(oldToken)?(await this.setAceToken(oldToken,!!localStorage.getItem("aceToken_encrypted")),oldToken):null}clearAceToken(){localStorage.removeItem(this.TOKEN_KEY),sessionStorage.removeItem(this.SESSION_TOKEN_KEY),localStorage.removeItem("aceToken_encrypted"),sessionStorage.removeItem("aceToken_session")}hasAceToken(){return!(!sessionStorage.getItem(this.SESSION_TOKEN_KEY)&amp;&amp;!localStorage.getItem(this.TOKEN_KEY))}isValidTokenFormat(token){if(!token)return!1;const parts=token.split(".");if(3!==parts.length)return!1;try{return parts.forEach(part=&gt;{atob(part.replace(/-/g,"+").replace(/_/g,"/"))}),!0}catch{return!1}}getTokenExpiration(token){if(!this.isValidTokenFormat(token))return null;try{const payload=JSON.parse(atob(token.split(".")[1]));if(payload.exp)return new Date(1e3*payload.exp)}catch(_error){}return null}isTokenExpired(token){const expiration=this.getTokenExpiration(token);return!expiration||expiration&lt;new Date}async setSecureItem(key,value){const encrypted=await this.encrypt(value);localStorage.setItem(`secure_v2_${key}`,encrypted)}async getSecureItem(key){const encrypted=localStorage.getItem(`secure_v2_${key}`);return encrypted?this.decrypt(encrypted):null}removeSecureItem(key){localStorage.removeItem(`secure_${key}`)}},secureStorage$1=Object.freeze(Object.defineProperty({__proto__:null,secureStorage:secureStorage},Symbol.toStringTag,{value:"Module"}));class BatchApiService{constructor(baseUrl,token,config={}){__publicField(this,"baseUrl"),__publicField(this,"token"),__publicField(this,"config"),__publicField(this,"requestQueue",[]),__publicField(this,"processingQueue",!1),__publicField(this,"batchTimeout",null),__publicField(this,"cache",new Map),__publicField(this,"pendingRequests",new Map),__publicField(this,"metrics",{totalRequests:0,batchRequests:0,cacheHits:0,cacheMisses:0,errors:0,averageResponseTime:0,deduplicationSaved:0}),this.baseUrl=baseUrl.replace(/\/$/,""),this.token=token,this.config={batchWindow:50,maxBatchSize:25,maxRetries:3,retryDelay:100,cacheEnabled:!0,cacheTTL:300,enableDeduplication:!0,...config}}async getTimeseries(request){this.metrics.totalRequests++;const requestKey=this.generateRequestKey(request);if(this.config.cacheEnabled){const cached=this.getFromCache(requestKey);if(cached)return this.metrics.cacheHits++,cached;this.metrics.cacheMisses++}if(this.config.enableDeduplication&amp;&amp;this.pendingRequests.has(requestKey))return this.metrics.deduplicationSaved++,this.pendingRequests.get(requestKey);const requestPromise=new Promise((resolve,reject)=&gt;{const queueItem={id:this.generateRequestId(),request:request,resolve:resolve,reject:reject,timestamp:Date.now(),retryCount:0};this.requestQueue.push(queueItem),this.scheduleProcessing()});return this.config.enableDeduplication&amp;&amp;(this.pendingRequests.set(requestKey,requestPromise),requestPromise.finally(()=&gt;{this.pendingRequests.delete(requestKey)})),requestPromise}async getMultiplePointTimeseries(pointIds,startTime,endTime,options){return(await this.getTimeseries({points:pointIds,start_time:startTime,end_time:endTime,options:options})).data}scheduleProcessing(){this.batchTimeout&amp;&amp;clearTimeout(this.batchTimeout),this.batchTimeout=setTimeout(()=&gt;{this.processBatch()},this.config.batchWindow)}async processBatch(){if(0!==this.requestQueue.length&amp;&amp;!this.processingQueue){this.processingQueue=!0;try{const batchPromises=this.createOptimalBatches().map(batch=&gt;this.processSingleBatch(batch));await Promise.all(batchPromises)}catch(error){console.error("Batch processing error:",error)}finally{this.processingQueue=!1,this.requestQueue.length&gt;0&amp;&amp;this.scheduleProcessing()}}}createOptimalBatches(){const batches=[],processed=new Set,sortedQueue=[...this.requestQueue].sort((a,b)=&gt;a.timestamp-b.timestamp);for(const item of sortedQueue){if(processed.has(item.id))continue;const batch=[item];processed.add(item.id);let totalPoints=item.request.points.length;for(const otherItem of sortedQueue)if(!processed.has(otherItem.id)&amp;&amp;this.canCombineRequests(item.request,otherItem.request)){const combinedPoints=totalPoints+otherItem.request.points.length;combinedPoints&lt;=this.config.maxBatchSize&amp;&amp;(batch.push(otherItem),totalPoints=combinedPoints,processed.add(otherItem.id))}batches.push(batch)}return this.requestQueue=this.requestQueue.filter(item=&gt;!processed.has(item.id)),batches}canCombineRequests(req1,req2){return req1.start_time===req2.start_time&amp;&amp;req1.end_time===req2.end_time&amp;&amp;JSON.stringify(req1.options||{})===JSON.stringify(req2.options||{})}async processSingleBatch(batch){try{const allPoints=batch.flatMap(item=&gt;item.request.points),uniquePoints=[...new Set(allPoints)],baseRequest=batch[0].request,combinedRequest={points:uniquePoints,start_time:baseRequest.start_time,end_time:baseRequest.end_time,options:baseRequest.options},response=await this.makeApiCall(combinedRequest);if(this.metrics.batchRequests++,this.config.cacheEnabled){const cacheKey=this.generateRequestKey(combinedRequest);this.setCache(cacheKey,response)}for(const item of batch)try{const filteredData={};for(const point of item.request.points)response.data[point]&amp;&amp;(filteredData[point]=response.data[point]);const filteredResponse={...response,points_requested:item.request.points.length,points_returned:Object.keys(filteredData).length,data:filteredData};item.resolve(filteredResponse)}catch(error){item.reject(new Error(`Failed to process individual response: ${error.message}`))}}catch(error){console.error("Batch API call failed:",error),this.metrics.errors++;const retriableBatch=batch.filter(item=&gt;item.retryCount&lt;this.config.maxRetries),failedBatch=batch.filter(item=&gt;item.retryCount&gt;=this.config.maxRetries);for(const item of failedBatch)item.reject(new Error(`Request failed after ${this.config.maxRetries} retries: ${error.message}`));retriableBatch.length&gt;0&amp;&amp;setTimeout(()=&gt;{for(const item of retriableBatch)item.retryCount++,this.requestQueue.push(item);this.scheduleProcessing()},this.config.retryDelay*Math.pow(2,retriableBatch[0].retryCount))}}async makeApiCall(request){const startTime=Date.now(),response=await fetch(`${this.baseUrl}/api/batch/timeseries`,{method:"POST",headers:{"Content-Type":"application/json","X-ACE-Token":this.token,"X-Batch-ID":this.generateBatchId()},body:JSON.stringify(request)});if(!response.ok){const errorText=await response.text();throw new Error(`API call failed: ${response.status} ${errorText}`)}const data=await response.json(),responseTime=Date.now()-startTime;return this.metrics.averageResponseTime=(this.metrics.averageResponseTime+responseTime)/2,data}generateRequestKey(request){return`${[...request.points].sort().join(",")}:${request.start_time}:${request.end_time}:${JSON.stringify(request.options||{})}`}generateRequestId(){return`req_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}generateBatchId(){return`batch_${Date.now()}_${Math.random().toString(36).substring(2,15)}`}getFromCache(key){const cached=this.cache.get(key);return cached&amp;&amp;cached.expires&gt;Date.now()?cached.data:(cached&amp;&amp;this.cache.delete(key),null)}setCache(key,data){if(this.cache.set(key,{data:data,expires:Date.now()+1e3*this.config.cacheTTL}),this.cache.size&gt;1e3){const now=Date.now();for(const[k,v]of this.cache.entries())v.expires&lt;=now&amp;&amp;this.cache.delete(k)}}clearCache(){this.cache.clear()}getMetrics(){return{...this.metrics,cacheSize:this.cache.size,queueSize:this.requestQueue.length,pendingRequests:this.pendingRequests.size}}updateConfig(newConfig){this.config={...this.config,...newConfig}}}let batchApiServiceInstance=null;function initializeBatchApiService(baseUrl,token,config){return batchApiServiceInstance=new BatchApiService(baseUrl,token,config),batchApiServiceInstance}function getAceApiToken$1(){try{const userToken=localStorage.getItem("aceIotApiToken");if(userToken&amp;&amp;validateAceToken(userToken))return console.log("[AceTokenResolver] Using user-configured ACE token from localStorage"),userToken}catch(error){console.error("[AceTokenResolver] Failed to read from localStorage:",error)}const envToken="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc1NzYxMTE4NiwianRpIjoiNjY1ZDM2NjMtZjFhZC00YWYxLTliZmEtNGMwMzRmMTllYjA4IiwidHlwZSI6ImFjY2VzcyIsImlkZW50aXR5Ijoic2VzXzAwMDFfZmFsbHNfY2l0eSIsIm5iZiI6MTc1NzYxMTE4NiwiZXhwIjoxNzg5MTQ3MTg2fQ.5g9JVBO_18x42srsJ4ZUNIqMbK6XeQDyrqqS-WEFc0g";if(validateAceToken(envToken))return console.log("[AceTokenResolver] Using environment ACE token"),envToken;try{const sessionToken=sessionStorage.getItem("aceIotApiToken");if(sessionToken&amp;&amp;validateAceToken(sessionToken))return console.log("[AceTokenResolver] Using session ACE token"),sessionToken}catch(error){console.error("[AceTokenResolver] Failed to read from sessionStorage:",error)}return console.warn("[AceTokenResolver] No valid ACE API token found"),null}function setAceApiToken(token){if(!validateAceToken(token))throw new Error("Invalid ACE API token format");try{localStorage.setItem("aceIotApiToken",token),console.log("[AceTokenResolver] ACE API token saved to localStorage")}catch(error){throw console.error("[AceTokenResolver] Failed to save ACE API token:",error),new Error("Failed to save ACE API token to localStorage")}}function validateAceToken(token){if(!token||"string"!=typeof token)return console.error("[AceTokenResolver] Token is missing or not a string"),!1;if((token=token.trim()).length&lt;50)return console.error("[AceTokenResolver] Token too short (minimum 50 characters for JWT)"),!1;return 3!==token.split(".").length?(console.error("[AceTokenResolver] Invalid JWT format - must have 3 parts (xxx.yyy.zzz)"),!1):!!token.startsWith("eyJ")||(console.error('[AceTokenResolver] Invalid JWT - should start with "eyJ"'),!1)}const aceTokenResolver=Object.freeze(Object.defineProperty({__proto__:null,getAceApiToken:getAceApiToken$1,setAceApiToken:setAceApiToken,validateAceToken:validateAceToken},Symbol.toStringTag,{value:"Module"})),_CachedSitePointService=class _CachedSitePointService{constructor(){}static getInstance(){return _CachedSitePointService.instance||(_CachedSitePointService.instance=new _CachedSitePointService),_CachedSitePointService.instance}async fetchSites(){try{const aceToken=store.getState().auth.aceToken;aceToken&amp;&amp;cloudflareWorkerClient.setToken(aceToken);const response=await cloudflareWorkerClient.fetchSites();console.log("[CachedSitePointService] Response from cloudflareWorkerClient:",response);const sites=(null==response?void 0:response.items)||[];return console.log(`[CachedSitePointService] Found ${sites.length} sites`),sites}catch(error){throw console.error("[CachedSitePointService] Failed to fetch sites:",error),error}}async fetchPointsForSite(siteId,_aceToken,_onProgress,collectEnabledOnly=!0,bypassCache=!1){try{const aceToken=_aceToken||store.getState().auth.aceToken;aceToken&amp;&amp;cloudflareWorkerClient.setToken(aceToken),console.log("[CachedSitePointService] fetchPointsForSite called with siteId:",siteId,"type:",typeof siteId);let siteIdentifier=siteId;if(!isNaN(parseInt(siteId,10))){console.log("[CachedSitePointService] Numeric site ID detected, need to convert:",siteId);const sitesResponse=await cloudflareWorkerClient.fetchSites(),site=((null==sitesResponse?void 0:sitesResponse.items)||[]).find(s=&gt;{var _a;return s.id===siteId||s.id===parseInt(siteId,10)||(null==(_a=s.id)?void 0:_a.toString())===siteId||parseInt(s.id,10)===parseInt(siteId,10)});site&amp;&amp;site.name?(console.log("[CachedSitePointService] Found site name:",site.name,"for ID:",siteId),siteIdentifier=site.name):console.warn("[CachedSitePointService] Could not find site name for ID:",siteId)}console.log("[CachedSitePointService] Using site identifier for API:",siteIdentifier);const response=await cloudflareWorkerClient.fetchPoints(siteIdentifier,bypassCache);let points=(null==response?void 0:response.items)||[];if(console.log("[CachedSitePointService] Points response:",{totalPoints:points.length,fromCache:null==response?void 0:response.fromCache,message:null==response?void 0:response.message,aiEnhanced:null==response?void 0:response.aiEnhanced}),console.log("[CachedSitePointService] Enhancing points with KV tags..."),points=points.map(point=&gt;{const mappedPoint={...point,displayName:point.display_name||point.displayName||point.name};if(hasKvTags(mappedPoint)){const enhanced=enhancePointWithKvTags(mappedPoint);return console.log("[CachedSitePointService] Enhanced point:",{original:enhanced.name,displayName:enhanced.displayName,equipment:enhanced.equipment,unit:enhanced.unit}),enhanced}return mappedPoint}),collectEnabledOnly){const filtered=points.filter(p=&gt;!1!==p.collect_enabled);console.log(`[CachedSitePointService] Filtered ${points.length} points to ${filtered.length} collect-enabled points`),points=filtered}return{all:points,grouped:this.groupPointsByCategory(points)}}catch(error){throw console.error("[CachedSitePointService] Failed to fetch points:",error),error}}async searchPoints(searchPattern,siteId){try{const aceToken=store.getState().auth.aceToken;if(aceToken&amp;&amp;cloudflareWorkerClient.setToken(aceToken),siteId){const response=await cloudflareWorkerClient.fetchPoints(siteId);return((null==response?void 0:response.items)||[]).filter(point=&gt;{var _a;return point.name.toLowerCase().includes(searchPattern.toLowerCase())||(null==(_a=point.description)?void 0:_a.toLowerCase().includes(searchPattern.toLowerCase()))})}{const sitesResponse=await cloudflareWorkerClient.fetchSites(),sites=(null==sitesResponse?void 0:sitesResponse.items)||[],allPoints=[];for(const site of sites)try{const response=await cloudflareWorkerClient.fetchPoints(site.id),points=(null==response?void 0:response.items)||[];allPoints.push(...points)}catch(err){console.warn(`Failed to fetch points for site ${site.id}:`,err)}return allPoints.filter(point=&gt;{var _a;return point.name.toLowerCase().includes(searchPattern.toLowerCase())||(null==(_a=point.description)?void 0:_a.toLowerCase().includes(searchPattern.toLowerCase()))})}}catch(error){throw console.error("[CachedSitePointService] Failed to search points:",error),error}}groupPointsByCategory(points){const grouped={};return points.forEach(point=&gt;{const category=point.point_type||"Other";grouped[category]||(grouped[category]=[]),grouped[category].push(point)}),grouped}async getAceToken(){const aceToken=store.getState().auth.aceToken;if(!aceToken)throw new Error("No ACE IoT token found. Please add your token in Settings.");return aceToken}async initialize(){}clearCache(){}async prefetchCommonData(){try{const aceToken=store.getState().auth.aceToken;if(!aceToken)return;cloudflareWorkerClient.setToken(aceToken),await cloudflareWorkerClient.fetchSites()}catch(error){console.debug("Prefetch error (non-critical):",error)}}};__publicField(_CachedSitePointService,"instance");const cachedSitePointService=_CachedSitePointService.getInstance();var TokenErrorType=(TokenErrorType2=&gt;(TokenErrorType2.NOT_FOUND="TOKEN_NOT_FOUND",TokenErrorType2.EXPIRED="TOKEN_EXPIRED",TokenErrorType2.INVALID_FORMAT="TOKEN_INVALID_FORMAT",TokenErrorType2.ENCRYPTION_FAILED="TOKEN_ENCRYPTION_FAILED",TokenErrorType2.DECRYPTION_FAILED="TOKEN_DECRYPTION_FAILED",TokenErrorType2.VALIDATION_FAILED="TOKEN_VALIDATION_FAILED",TokenErrorType2.STORAGE_FAILED="TOKEN_STORAGE_FAILED",TokenErrorType2.NETWORK_ERROR="TOKEN_NETWORK_ERROR",TokenErrorType2.PERMISSION_DENIED="TOKEN_PERMISSION_DENIED",TokenErrorType2.UNKNOWN="TOKEN_UNKNOWN_ERROR",TokenErrorType2))(TokenErrorType||{});class TokenError extends Error{constructor(type,message,cause,context){super(message),__publicField(this,"type"),__publicField(this,"cause"),__publicField(this,"context"),this.name="TokenError",this.type=type,this.cause=cause,this.context=context,Error.captureStackTrace&amp;&amp;Error.captureStackTrace(this,TokenError)}}const TOKEN_CONSTANTS_DEFAULT_WARNING_DAYS=7,TOKEN_CONSTANTS_DEFAULT_URGENT_DAYS=3,TOKEN_CONSTANTS_DEFAULT_CACHE_TTL=300,TOKEN_CONSTANTS_MAX_TOKEN_LENGTH=1e4,TOKEN_CONSTANTS_MIN_TOKEN_LENGTH=20;let PRECONFIGURED_SITES=[{siteId:"ses_falls_city",siteName:"ses_falls_city",displayName:"SES Falls City Medical Center",description:"Falls City Community Medical Center - Full HVAC monitoring",token:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc1NzYxMTE4NiwianRpIjoiNjY1ZDM2NjMtZjFhZC00YWYxLTliZmEtNGMwMzRmMTllYjA4IiwidHlwZSI6ImFjY2VzcyIsImlkZW50aXR5Ijoic2VzXzAwMDFfZmFsbHNfY2l0eSIsIm5iZiI6MTc1NzYxMTE4NiwiZXhwIjoxNzg5MTQ3MTg2fQ.5g9JVBO_18x42srsJ4ZUNIqMbK6XeQDyrqqS-WEFc0g",identity:"ses_0001_falls_city",region:"US-Central",pointCount:8535,features:["VAV Control","RTU Monitoring","AHU Systems","Boiler","Chiller"]}];(()=&gt;{try{const stored=localStorage.getItem("custom_ace_sites");if(stored){JSON.parse(stored).forEach(site=&gt;{const index=PRECONFIGURED_SITES.findIndex(s=&gt;s.siteId===site.siteId);index&gt;=0?PRECONFIGURED_SITES[index]=site:PRECONFIGURED_SITES.push(site)})}}catch(error){console.error("Failed to load custom sites:",error)}})();const getTokenForSite=siteId=&gt;{const site=PRECONFIGURED_SITES.find(s=&gt;s.siteId===siteId||s.siteName===siteId||s.siteId===String(siteId));return(null==site?void 0:site.token)||null},isSiteConfigured=siteId=&gt;PRECONFIGURED_SITES.some(s=&gt;s.siteId===siteId||s.siteName===siteId),hasDefaultToken$1=siteId=&gt;isSiteConfigured(siteId),_MultiTokenManager=class _MultiTokenManager extends EventEmitter{constructor(config){super(),__publicField(this,"config"),__publicField(this,"tokenCache",new Map),__publicField(this,"currentSiteId",null),__publicField(this,"initialized",!1),__publicField(this,"cacheCleanupTimer",null),this.config={cacheTTL:(null==config?void 0:config.cacheTTL)??1e3*TOKEN_CONSTANTS_DEFAULT_CACHE_TTL,enableAutoValidation:(null==config?void 0:config.enableAutoValidation)??!0,enableEventLogging:(null==config?void 0:config.enableEventLogging)??!1},this.initializeCache(),this.log("MultiTokenManager initialized",{config:this.config})}static getInstance(config){return _MultiTokenManager.instance||(_MultiTokenManager.instance=new _MultiTokenManager(config)),_MultiTokenManager.instance}static resetInstance(){_MultiTokenManager.instance&amp;&amp;(_MultiTokenManager.instance.destroy(),_MultiTokenManager.instance=null)}async addToken(siteId,token,options){try{this.validateSiteId(siteId),this.validateTokenString(token);const siteName=await this.getSiteName(siteId),existingToken=this.tokenCache.get(siteId),siteToken=await this.storeToken(siteId,siteName,token,options);this.updateCache(siteId,siteToken),existingToken?this.emit("tokenUpdated",{siteId:siteId,siteName:siteName,token:siteToken,previousToken:existingToken.token,timestamp:Date.now()}):this.emit("tokenAdded",{siteId:siteId,siteName:siteName,token:siteToken,timestamp:Date.now()}),this.log("Token added/updated",{siteId:siteId,siteName:siteName})}catch(error){const tokenError=this.handleError(error,"addToken",{siteId:siteId});throw this.emit("error",tokenError),tokenError}}async getToken(siteId,options){try{this.validateSiteId(siteId);const cached=this.getCachedToken(siteId);if(cached){const cacheAge=Date.now()-cached.cachedAt;if(this.log("Cache hit",{siteId:siteId,age:cacheAge}),(null==options?void 0:options.validate)&amp;&amp;this.config.enableAutoValidation){if(!(await this.validateToken(siteId)).isValid&amp;&amp;!options.allowExpired)return null}return(null==options?void 0:options.updateLastUsed)&amp;&amp;await this.updateLastUsed(siteId),cached.token.token}this.log("Cache miss",{siteId:siteId});const siteToken=await this.loadTokenFromStorage(siteId);if(!siteToken){if(hasDefaultToken$1(siteId)){const defaultToken=(siteId=&gt;getTokenForSite(siteId))(siteId);return this.log("Using default token",{siteId:siteId}),defaultToken}return null}return siteToken.expiresAt&amp;&amp;!(null==options?void 0:options.allowExpired)&amp;&amp;new Date&gt;siteToken.expiresAt?(this.log("Token expired",{siteId:siteId,expiresAt:siteToken.expiresAt}),null):(this.updateCache(siteId,siteToken),(null==options?void 0:options.updateLastUsed)&amp;&amp;await this.updateLastUsed(siteId),siteToken.token)}catch(error){const tokenError=this.handleError(error,"getToken",{siteId:siteId});return this.emit("error",tokenError),null}}async removeToken(siteId){try{this.validateSiteId(siteId);const cached=this.tokenCache.get(siteId),siteName=(null==cached?void 0:cached.token.siteName)||siteId;await this.deleteTokenFromStorage(siteId),this.invalidateCache(siteId),this.currentSiteId===siteId&amp;&amp;(this.currentSiteId=null),this.emit("tokenRemoved",{siteId:siteId,siteName:siteName,timestamp:Date.now()}),this.log("Token removed",{siteId:siteId,siteName:siteName})}catch(error){const tokenError=this.handleError(error,"removeToken",{siteId:siteId});throw this.emit("error",tokenError),tokenError}}async getAllSiteTokens(){try{const tokens=await this.loadAllTokensFromStorage();return tokens.forEach((token,siteId)=&gt;{this.updateCache(siteId,token)}),this.log("Loaded all tokens",{count:tokens.size}),tokens}catch(error){const tokenError=this.handleError(error,"getAllSiteTokens",{});throw this.emit("error",tokenError),tokenError}}setCurrentSite(siteId){this.validateSiteId(siteId);if(!(this.tokenCache.has(siteId)||hasDefaultToken$1(siteId)))throw new TokenError(TokenErrorType.NOT_FOUND,`No token found for site: ${siteId}`,void 0,{siteId:siteId});const previousSiteId=this.currentSiteId;this.currentSiteId=siteId;const cached=this.tokenCache.get(siteId),siteName=(null==cached?void 0:cached.token.siteName)||siteId;this.emit("currentSiteChanged",{siteId:siteId,siteName:siteName,previousSiteId:previousSiteId,timestamp:Date.now()}),this.log("Current site changed",{siteId:siteId,previousSiteId:previousSiteId})}getCurrentSite(){return this.currentSiteId}async validateToken(siteId){try{this.validateSiteId(siteId);const token=await this.getToken(siteId,{allowExpired:!0});return token?await this.performValidation(token):{isValid:!1,isExpired:!1,status:"expired",expiresAt:null,daysUntilExpiration:null,errors:["Token not found"],warnings:[]}}catch(error){return{isValid:!1,isExpired:!1,status:"expired",expiresAt:null,daysUntilExpiration:null,errors:[error instanceof Error?error.message:"Validation failed"],warnings:[]}}}invalidateCache(siteId){if(siteId)this.tokenCache.delete(siteId),this.emit("cacheInvalidated",siteId),this.log("Cache invalidated",{siteId:siteId});else{const count=this.tokenCache.size;this.tokenCache.clear(),this.log("All cache cleared",{entriesRemoved:count})}}async getTokenMetadata(siteId){try{this.validateSiteId(siteId);const cached=this.getCachedToken(siteId);if(null==cached?void 0:cached.token.metadata)return cached.token.metadata;const siteToken=await this.loadTokenFromStorage(siteId);return(null==siteToken?void 0:siteToken.metadata)||null}catch(error){return this.log("Failed to get metadata",{siteId:siteId,error:error}),null}}async refreshToken(siteId){try{this.validateSiteId(siteId),this.invalidateCache(siteId);const siteToken=await this.loadTokenFromStorage(siteId);if(!siteToken)throw new TokenError(TokenErrorType.NOT_FOUND,`Token not found for site: ${siteId}`,void 0,{siteId:siteId});this.updateCache(siteId,siteToken),this.log("Token refreshed",{siteId:siteId})}catch(error){const tokenError=this.handleError(error,"refreshToken",{siteId:siteId});throw this.emit("error",tokenError),tokenError}}async hasToken(siteId){try{if(this.validateSiteId(siteId),this.tokenCache.has(siteId))return!0;if(hasDefaultToken$1(siteId))return!0;return null!==await this.loadTokenFromStorage(siteId)}catch(error){return this.log("hasToken check failed",{siteId:siteId,error:error}),!1}}getStatistics(){var _a;const stats={totalTokens:this.tokenCache.size,activeTokens:0,expiredTokens:0,expiringSoon:0,bySource:{user:0,default:0,admin:0},byStatus:{active:0,warning:0,urgent:0,expired:0},avgDaysUntilExpiration:null,lastUpdated:new Date},daysUntilExp=[];for(const[_,entry]of Array.from(this.tokenCache.entries())){const token=entry.token;if((null==(_a=token.metadata)?void 0:_a.source)&amp;&amp;stats.bySource[token.metadata.source]++,token.expiresAt){const now=new Date,daysUntil=Math.ceil((token.expiresAt.getTime()-now.getTime())/864e5);daysUntil&lt;=0?(stats.expiredTokens++,stats.byStatus.expired++):(stats.activeTokens++,daysUntilExp.push(daysUntil),daysUntil&lt;=3?(stats.expiringSoon++,stats.byStatus.urgent++):daysUntil&lt;=7?(stats.expiringSoon++,stats.byStatus.warning++):stats.byStatus.active++)}else stats.activeTokens++,stats.byStatus.active++}return daysUntilExp.length&gt;0&amp;&amp;(stats.avgDaysUntilExpiration=daysUntilExp.reduce((a,b)=&gt;a+b,0)/daysUntilExp.length),stats}initializeCache(){this.initialized||(this.cacheCleanupTimer=setInterval(()=&gt;{this.cleanupExpiredCache()},this.config.cacheTTL),this.initialized=!0,this.log("Cache initialized",{ttl:this.config.cacheTTL}))}updateCache(siteId,token){const now=Date.now();this.tokenCache.set(siteId,{token:token,cachedAt:now,expiresAt:now+this.config.cacheTTL})}getCachedToken(siteId){const cached=this.tokenCache.get(siteId);return cached?Date.now()&gt;cached.expiresAt?(this.tokenCache.delete(siteId),null):cached:null}cleanupExpiredCache(){const now=Date.now();let removed=0;for(const[siteId,entry]of Array.from(this.tokenCache.entries()))now&gt;entry.expiresAt&amp;&amp;(this.tokenCache.delete(siteId),removed++);removed&gt;0&amp;&amp;this.log("Cache cleanup",{entriesRemoved:removed})}async storeToken(siteId,siteName,token,options){try{const decoded=jwtDecode(token),expiresAt=decoded.exp?new Date(1e3*decoded.exp):null;return{siteId:siteId,siteName:siteName,token:token,tokenHash:this.hashToken(token),createdAt:new Date,updatedAt:new Date,expiresAt:expiresAt,isDefault:!1,lastUsed:new Date,metadata:{source:"user",...null==options?void 0:options.metadata}}}catch(error){throw new TokenError(TokenErrorType.INVALID_FORMAT,"Failed to parse JWT token",error instanceof Error?error:void 0,{siteId:siteId})}}async loadTokenFromStorage(siteId){return this.log("loadTokenFromStorage placeholder",{siteId:siteId}),null}async loadAllTokensFromStorage(){return this.log("loadAllTokensFromStorage placeholder"),new Map}async deleteTokenFromStorage(siteId){this.log("deleteTokenFromStorage placeholder",{siteId:siteId})}async getSiteName(siteId){return siteId}async updateLastUsed(siteId){this.log("updateLastUsed placeholder",{siteId:siteId})}async performValidation(token){const validation={isValid:!0,isExpired:!1,status:"active",expiresAt:null,daysUntilExpiration:null,errors:[],warnings:[]};try{if(!this.isValidJWT(token))return validation.isValid=!1,validation.errors.push("Invalid JWT format"),validation;const decoded=jwtDecode(token);if(validation.claims=decoded,decoded.exp){validation.expiresAt=new Date(1e3*decoded.exp);const now=new Date,daysUntil=Math.ceil((validation.expiresAt.getTime()-now.getTime())/864e5);validation.daysUntilExpiration=daysUntil,daysUntil&lt;=0?(validation.isExpired=!0,validation.isValid=!1,validation.status="expired",validation.errors.push("Token has expired")):daysUntil&lt;=TOKEN_CONSTANTS_DEFAULT_URGENT_DAYS?(validation.status="urgent",validation.warnings.push(`Token expires in ${daysUntil} days`)):daysUntil&lt;=TOKEN_CONSTANTS_DEFAULT_WARNING_DAYS&amp;&amp;(validation.status="warning",validation.warnings.push(`Token expires in ${daysUntil} days`))}return validation}catch(error){return validation.isValid=!1,validation.errors.push("Failed to decode JWT token"),validation}}validateSiteId(siteId){if(!siteId||"string"!=typeof siteId||0===siteId.trim().length)throw new TokenError(TokenErrorType.VALIDATION_FAILED,"Invalid site ID: must be a non-empty string",void 0,{siteId:siteId})}validateTokenString(token){if(!token||"string"!=typeof token)throw new TokenError(TokenErrorType.INVALID_FORMAT,"Token must be a non-empty string");if(token.length&lt;TOKEN_CONSTANTS_MIN_TOKEN_LENGTH)throw new TokenError(TokenErrorType.INVALID_FORMAT,`Token too short (min: ${TOKEN_CONSTANTS_MIN_TOKEN_LENGTH} characters)`);if(token.length&gt;TOKEN_CONSTANTS_MAX_TOKEN_LENGTH)throw new TokenError(TokenErrorType.INVALID_FORMAT,`Token too long (max: ${TOKEN_CONSTANTS_MAX_TOKEN_LENGTH} characters)`)}isValidJWT(token){const parts=token.split(".");return 3===parts.length&amp;&amp;parts.every(part=&gt;part.length&gt;0)}hashToken(token){let hash=0;for(let i=0;i&lt;token.length;i++){hash=(hash&lt;&lt;5)-hash+token.charCodeAt(i),hash&amp;=hash}return`hash_${Math.abs(hash).toString(16)}`}handleError(error,operation,context){if(error instanceof TokenError)return error;const message=error instanceof Error?error.message:"Unknown error occurred";return new TokenError(TokenErrorType.UNKNOWN,`${operation} failed: ${message}`,error instanceof Error?error:void 0,{...context,operation:operation})}log(message,data){this.config.enableEventLogging&amp;&amp;console.log(`[MultiTokenManager] ${message}`,data||"")}destroy(){this.cacheCleanupTimer&amp;&amp;(clearInterval(this.cacheCleanupTimer),this.cacheCleanupTimer=null),this.tokenCache.clear(),this.removeAllListeners(),this.initialized=!1,this.log("MultiTokenManager destroyed")}};__publicField(_MultiTokenManager,"instance",null);let MultiTokenManager=_MultiTokenManager;const DEFAULT_CONFIG={apiBaseUrl:"https://ace-iot-consolidated-proxy.jstahr.workers.dev",apiTimeout:1e4,warningDays:7,urgentDays:3,criticalDays:1};class TokenValidator{constructor(config){__publicField(this,"config"),this.config={...DEFAULT_CONFIG,...config}}updateConfig(config){this.config={...this.config,...config}}async validate(token){const errors=[],warnings=[];if(!this.isValidFormat(token))return{isValid:!1,isExpired:!1,status:"expired",expiresAt:null,daysUntilExpiration:null,errors:["Invalid JWT format: Token must have exactly 3 parts (header.payload.signature)"],warnings:[]};const payload=this.decodeJWT(token);if(!payload)return{isValid:!1,isExpired:!1,status:"expired",expiresAt:null,daysUntilExpiration:null,errors:["Invalid JWT encoding: Unable to decode token payload"],warnings:[]};const expiryStatus=this.checkExpiration(token);if(expiryStatus.isExpired)errors.push("Token has expired");else if(expiryStatus.isExpiringSoon){const daysMsg=1===expiryStatus.daysUntilExpiration?"1 day":`${expiryStatus.daysUntilExpiration} days`;warnings.push(`Token expires in ${daysMsg}`)}return{isValid:!expiryStatus.isExpired,isExpired:expiryStatus.isExpired,status:expiryStatus.status,expiresAt:expiryStatus.expiresAt,daysUntilExpiration:expiryStatus.daysUntilExpiration,errors:errors,warnings:warnings,claims:payload}}decodeJWT(token){try{const parts=token.split(".");if(3!==parts.length)return null;const base64=parts[1].replace(/-/g,"+").replace(/_/g,"/"),padded=base64.padEnd(base64.length+(4-base64.length%4)%4,"="),decoded=atob(padded);return JSON.parse(decoded)}catch(error){return null}}checkExpiration(token){const payload=this.decodeJWT(token);if(!payload||!payload.exp)return{status:"active",isExpired:!1,isExpiringSoon:!1,expiresAt:null,daysUntilExpiration:null,message:"Token has no expiration date",recommendedAction:"none"};const expiresAt=new Date(1e3*payload.exp),daysRemaining=this.getDaysUntilExpiry(payload.exp),status=this.getExpiryStatus(daysRemaining),isExpired=daysRemaining&lt;=0,isExpiringSoon=daysRemaining&gt;0&amp;&amp;daysRemaining&lt;=this.config.warningDays;let message,recommendedAction;if(isExpired){const daysAgo=Math.abs(daysRemaining);message=0===daysAgo?"Token expired today":`Token expired ${daysAgo} day${1===daysAgo?"":"s"} ago`,recommendedAction="renew_now"}else daysRemaining&lt;=this.config.criticalDays?(message=daysRemaining&lt;1?"Token expires in less than 1 day":`Token expires in ${daysRemaining} day${1===daysRemaining?"":"s"}`,recommendedAction="renew_now"):daysRemaining&lt;=this.config.urgentDays?(message=`Token expires in ${daysRemaining} days`,recommendedAction="renew_soon"):daysRemaining&lt;=this.config.warningDays?(message=`Token expires in ${daysRemaining} days`,recommendedAction="monitor"):(message=`Token expires in ${daysRemaining} days`,recommendedAction="none");return{status:status,isExpired:isExpired,isExpiringSoon:isExpiringSoon,expiresAt:expiresAt,daysUntilExpiration:daysRemaining,message:message,recommendedAction:recommendedAction}}async testWithAPI(token){try{const controller=new AbortController,timeoutId=setTimeout(()=&gt;controller.abort(),this.config.apiTimeout),response=await fetch(`${this.config.apiBaseUrl}/sites`,{method:"GET",headers:{"X-ACE-Token":token,"Content-Type":"application/json"},signal:controller.signal});return clearTimeout(timeoutId),response.ok}catch(error){return error instanceof Error&amp;&amp;("AbortError"===error.name?console.warn("[TokenValidator] API test timed out"):console.warn("[TokenValidator] API test failed:",error.message)),!1}}isValidFormat(token){if(!token||"string"!=typeof token)return!1;const trimmed=token.trim();if(0===trimmed.length)return!1;if(trimmed.length&lt;TOKEN_CONSTANTS_MIN_TOKEN_LENGTH||trimmed.length&gt;TOKEN_CONSTANTS_MAX_TOKEN_LENGTH)return!1;const parts=trimmed.split(".");return 3===parts.length&amp;&amp;!parts.some(part=&gt;0===part.length)}getDaysUntilExpiry(exp){const secondsRemaining=exp-Date.now()/1e3;return Math.ceil(secondsRemaining/86400)}getExpiryStatus(daysRemaining){return daysRemaining&lt;=0?"expired":daysRemaining&lt;=this.config.criticalDays||daysRemaining&lt;=this.config.urgentDays?"urgent":daysRemaining&lt;=this.config.warningDays?"warning":"active"}formatTokenForDisplay(token){if(!token||token.length&lt;4)return"****";return`****${token.slice(-4)}`}getTokenMetadata(token){const payload=this.decodeJWT(token);return payload?{issuer:payload.iss,subject:payload.sub,audience:payload.aud,issuedAt:payload.iat?new Date(1e3*payload.iat):void 0,expiresAt:payload.exp?new Date(1e3*payload.exp):void 0,notBefore:payload.nbf?new Date(1e3*payload.nbf):void 0,jti:payload.jti}:null}async validateBatch(tokens){return Promise.all(tokens.map(token=&gt;this.validate(token)))}quickValidate(token){const errors=[];if(!this.isValidFormat(token))return{isValid:!1,isExpired:!1,status:"expired",daysUntilExpiration:null,errors:["Invalid JWT format"]};if(!this.decodeJWT(token))return{isValid:!1,isExpired:!1,status:"expired",daysUntilExpiration:null,errors:["Invalid JWT encoding"]};const expiryStatus=this.checkExpiration(token);return expiryStatus.isExpired&amp;&amp;errors.push("Token has expired"),{isValid:!expiryStatus.isExpired,isExpired:expiryStatus.isExpired,status:expiryStatus.status,daysUntilExpiration:expiryStatus.daysUntilExpiration,errors:errors}}}new TokenValidator;const logger$2=new class LoggingService{constructor(){__publicField(this,"correlationId",""),__publicField(this,"logsBuffer",[]),__publicField(this,"isBufferFlushing",!1),__publicField(this,"flushInterval",1e4),__publicField(this,"flushIntervalId",null),__publicField(this,"consoleOutputEnabled",!0),__publicField(this,"serverLoggingEnabled",!0),__publicField(this,"debugMode",!1),this.correlationId=this.generateCorrelationId(),this.startPeriodicFlush(),this.consoleOutputEnabled="false"!==localStorage.getItem("log_console_output"),this.serverLoggingEnabled="false"!==localStorage.getItem("log_server_output"),this.debugMode="true"===localStorage.getItem("debug_mode")}generateCorrelationId(){return Date.now().toString(36)+Math.random().toString(36).substring(2)}startSession(){this.correlationId=this.generateCorrelationId(),this.info("api","New logging session started",{newCorrelationId:this.correlationId})}getCorrelationId(){return this.correlationId}debug(category,message,metadata){this.debugMode&amp;&amp;this.logMessage("debug",category,message,metadata)}info(category,message,metadata){this.logMessage("info",category,message,metadata)}warn(category,message,metadata){this.logMessage("warn",category,message,metadata)}error(category,message,metadata){this.logMessage("error",category,message,metadata)}critical(category,message,metadata){this.logMessage("critical",category,message,metadata),this.flush()}logMessage(level,category,message,metadata){var _a;try{const userId=null==(_a=getAuth().currentUser)?void 0:_a.uid,logEntry={timestamp:(new Date).toISOString(),level:level,category:category,message:message,userId:userId,correlationId:this.correlationId,metadata:metadata};if(this.logsBuffer.push(logEntry),this.consoleOutputEnabled){level.toUpperCase();level}this.logsBuffer.length&gt;=20&amp;&amp;this.flush()}catch(_error){console.error("Failed to add log entry:",_error)}}flush(){if(!this.serverLoggingEnabled||0===this.logsBuffer.length||this.isBufferFlushing)return;this.isBufferFlushing=!0;const logsToSend=[...this.logsBuffer];this.logsBuffer=[];try{const functions=getFunctions();httpsCallable(functions,"sendLogs")({logs:logsToSend}).then(()=&gt;{this.isBufferFlushing=!1}).catch(_error=&gt;{this.logsBuffer=[...logsToSend,...this.logsBuffer]})}catch(_error){this.logsBuffer=[...logsToSend,...this.logsBuffer]}}startPeriodicFlush(){this.flushIntervalId&amp;&amp;clearInterval(this.flushIntervalId),this.flushIntervalId=setInterval(()=&gt;{this.flush()},this.flushInterval)}dispose(){this.flushIntervalId&amp;&amp;(clearInterval(this.flushIntervalId),this.flushIntervalId=null),this.flush()}},DEFAULT_SITE_ID$1="default_migrated_site";class TokenMigrationService{constructor(){__publicField(this,"_tokenService"),__publicField(this,"_multiTokenManager"),__publicField(this,"_tokenValidator")}get tokenService(){return this._tokenService||(this._tokenService=getTokenService()),this._tokenService}get multiTokenManager(){return this._multiTokenManager||(this._multiTokenManager=MultiTokenManager.getInstance()),this._multiTokenManager}get tokenValidator(){return this._tokenValidator||(this._tokenValidator=new TokenValidator),this._tokenValidator}async checkMigrationStatus(userId){const status={needsMigration:!1,migrated:!1,migratedAt:null,legacyTokenExists:!1,multiSiteTokensCount:0,errors:[]};try{const userRef=doc(db,"users",userId),userDoc=await getDoc(userRef);if(userDoc.exists()){const data=userDoc.data();status.migrated=!0===data.tokenMigrated,status.migratedAt=data.tokenMigratedAt?new Date(data.tokenMigratedAt):null,status.legacyTokenExists=!!data.aceJwt}const multiSiteTokens=await this.multiTokenManager.getAllSiteTokens();status.multiSiteTokensCount=multiSiteTokens.size,status.needsMigration=status.legacyTokenExists&amp;&amp;!status.migrated&amp;&amp;0===status.multiSiteTokensCount}catch(error){const errorMsg=error instanceof Error?error.message:"Unknown error";status.errors.push(`Failed to check migration status: ${errorMsg}`),logger$2.error("Migration status check failed",{userId:userId,error:errorMsg})}return status}async migrateUser(userId,options={}){const{preserveLegacy:preserveLegacy=!1,defaultSiteId:defaultSiteId=DEFAULT_SITE_ID$1,autoMigrate:autoMigrate=!1,dryRun:dryRun=!1}=options;logger$2.info("Starting token migration",{userId:userId,options:options});try{const legacyToken=await this.tokenService.getToken(userId);if(!legacyToken)throw new Error("No legacy token found for migration");logger$2.info("Legacy token retrieved",{userId:userId,tokenLength:legacyToken.length});const validation=await this.tokenValidator.validate(legacyToken);if(!validation.isValid)throw new Error(`Legacy token is invalid: ${validation.errors.join(", ")}`);if(logger$2.info("Legacy token validated",{userId:userId,status:validation.status}),dryRun)return void logger$2.info("DRY RUN: Would migrate token to siteId",{userId:userId,defaultSiteId:defaultSiteId});await this.multiTokenManager.addToken(defaultSiteId,legacyToken,{metadata:{source:"user",notes:"Migrated from legacy system",createdBy:userId,environment:"production"}}),logger$2.info("Token added to multi-site system",{userId:userId,siteId:defaultSiteId});const userRef=doc(db,"users",userId);await updateDoc(userRef,{tokenMigrated:!0,tokenMigratedAt:(new Date).toISOString(),tokenMigrationVersion:"1.0.0",tokenMigrationSiteId:defaultSiteId,tokenMigrationSource:autoMigrate?"automatic":"manual"}),logger$2.info("Migration metadata stored",{userId:userId}),preserveLegacy?logger$2.info("Legacy token preserved",{userId:userId}):(await this.tokenService.removeToken(userId),logger$2.info("Legacy token removed",{userId:userId})),logger$2.info("Migration completed successfully",{userId:userId,preserveLegacy:preserveLegacy})}catch(error){const errorMsg=error instanceof Error?error.message:"Unknown error";throw logger$2.error("Migration failed",{userId:userId,error:errorMsg}),new Error(`Migration failed: ${errorMsg}`)}}async migrateAllUsers(options={}){const report={total:0,successful:0,failed:0,skipped:0,errors:[],startTime:new Date,endTime:new Date,duration:0};try{logger$2.info("Starting batch migration",{options:options});const usersRef=collection(db,"users"),usersSnapshot=await getDocs(usersRef);report.total=usersSnapshot.size,logger$2.info("Found users to process",{count:report.total});for(const userDoc of usersSnapshot.docs){const userId=userDoc.id;try{if(!(await this.checkMigrationStatus(userId)).needsMigration){report.skipped++,logger$2.debug("User skipped - no migration needed",{userId:userId});continue}await this.migrateUser(userId,options),report.successful++,logger$2.info("User migrated successfully",{userId:userId})}catch(error){report.failed++;const errorMsg=error instanceof Error?error.message:"Unknown error";report.errors.push({userId:userId,error:errorMsg}),logger$2.error("User migration failed",{userId:userId,error:errorMsg})}}return report.endTime=new Date,report.duration=report.endTime.getTime()-report.startTime.getTime(),logger$2.info("Batch migration completed",{report:report}),report}catch(error){const errorMsg=error instanceof Error?error.message:"Unknown error";throw logger$2.error("Batch migration failed",{error:errorMsg}),new Error(`Batch migration failed: ${errorMsg}`)}}async rollbackMigration(userId){logger$2.info("Starting migration rollback",{userId:userId});try{const userRef=doc(db,"users",userId),userDoc=await getDoc(userRef);if(!userDoc.exists())throw new Error("User document not found");const data=userDoc.data();if(!data.tokenMigrated)throw new Error("User has not been migrated");const migrationSiteId=data.tokenMigrationSiteId||DEFAULT_SITE_ID$1;await this.multiTokenManager.removeToken(migrationSiteId),logger$2.info("Token removed from multi-site system",{userId:userId,siteId:migrationSiteId}),await updateDoc(userRef,{tokenMigrated:!1,tokenMigratedAt:null,tokenMigrationVersion:null,tokenMigrationSiteId:null,tokenMigrationSource:null,tokenRolledBackAt:(new Date).toISOString()}),logger$2.info("Migration rollback completed",{userId:userId})}catch(error){const errorMsg=error instanceof Error?error.message:"Unknown error";throw logger$2.error("Rollback failed",{userId:userId,error:errorMsg}),new Error(`Rollback failed: ${errorMsg}`)}}async verifyMigration(userId){try{logger$2.info("Verifying migration",{userId:userId});if(!(await this.checkMigrationStatus(userId)).migrated)return logger$2.warn("User not migrated",{userId:userId}),!1;const userRef=doc(db,"users",userId),userDoc=await getDoc(userRef);if(!userDoc.exists())return logger$2.error("User document not found",{userId:userId}),!1;const migrationSiteId=userDoc.data().tokenMigrationSiteId||DEFAULT_SITE_ID$1,token=await this.multiTokenManager.getToken(migrationSiteId);if(!token)return logger$2.error("Migrated token not found in multi-site system",{userId:userId,siteId:migrationSiteId}),!1;const validation=await this.tokenValidator.validate(token);return validation.isValid?(logger$2.info("Migration verified successfully",{userId:userId}),!0):(logger$2.error("Migrated token is invalid",{userId:userId,errors:validation.errors}),!1)}catch(error){const errorMsg=error instanceof Error?error.message:"Unknown error";return logger$2.error("Verification failed",{userId:userId,error:errorMsg}),!1}}async getMigrationStatistics(){try{const usersRef=collection(db,"users"),usersSnapshot=await getDocs(usersRef),totalUsers=usersSnapshot.size;let migratedUsers=0,pendingMigration=0,failedMigration=0;for(const userDoc of usersSnapshot.docs){const data=userDoc.data();if(data.tokenMigrated?migratedUsers++:data.aceJwt&amp;&amp;pendingMigration++,data.tokenMigrated){await this.verifyMigration(userDoc.id)||failedMigration++}}return{totalUsers:totalUsers,migratedUsers:migratedUsers,pendingMigration:pendingMigration,failedMigration:failedMigration}}catch(error){throw logger$2.error("Failed to get migration statistics",{error:error}),error}}}const tokenMigrationService=new TokenMigrationService,tokenMigration=Object.freeze(Object.defineProperty({__proto__:null,TokenMigrationService:TokenMigrationService,initializeTokenMigration:async function initializeTokenMigration(){const currentUser=auth.currentUser;if(currentUser)try{const{FEATURE_FLAGS:FEATURE_FLAGS}=await __vitePreload(async()=&gt;{const{FEATURE_FLAGS:FEATURE_FLAGS2}=await import("./app-core-rH6lZf1X.js").then(n=&gt;n.ag);return{FEATURE_FLAGS:FEATURE_FLAGS2}},__vite__mapDeps([0,1,2,3,4,5,6,7,8,9])),migrationService=new TokenMigrationService;if((await migrationService.checkMigrationStatus(currentUser.uid)).needsMigration&amp;&amp;FEATURE_FLAGS.AUTO_MIGRATE_TOKENS){logger$2.info("Auto-migration triggered",{userId:currentUser.uid});try{await migrationService.migrateUser(currentUser.uid,{autoMigrate:!0,preserveLegacy:!0}),logger$2.info("Auto-migration successful",{userId:currentUser.uid})}catch(error){logger$2.error("Auto-migration failed",{userId:currentUser.uid,error:error})}}}catch(error){logger$2.error("Migration initialization failed",{error:error})}},tokenMigrationService:tokenMigrationService},Symbol.toStringTag,{value:"Module"}));const tokenExpirationMonitor=new class TokenExpirationMonitor{constructor(){__publicField(this,"intervalId",null)}startMonitoring(){this.stopMonitoring(),this.intervalId=setInterval(()=&gt;{this.checkNow()},3e5)}stopMonitoring(){this.intervalId&amp;&amp;(clearInterval(this.intervalId),this.intervalId=null)}checkNow(){const token=store.getState().auth.aceToken;if(token)try{const decoded=jwtDecode(token);if(decoded.exp){const expirationTime=1e3*decoded.exp,timeUntilExpiry=expirationTime-Date.now();timeUntilExpiry&lt;864e5&amp;&amp;console.warn("ACE token will expire soon:",new Date(expirationTime).toLocaleString()),timeUntilExpiry&lt;=0&amp;&amp;console.error("ACE token has expired")}}catch(error){console.error("Failed to check token expiration:",error)}}};const pointSearchOptimizer=new class PointSearchOptimizer{constructor(){__publicField(this,"indexes",new Map),__publicField(this,"indexBuildPromises",new Map),__publicField(this,"INDEX_TTL",6e5),__publicField(this,"CHUNK_SIZE",5e3),__publicField(this,"MIN_SEARCH_LENGTH",2),__publicField(this,"performanceMarks",new Map)}startMeasure(label){this.performanceMarks.set(label,performance.now())}endMeasure(label,threshold=100){const start=this.performanceMarks.get(label);if(!start)return 0;const duration=performance.now()-start;if(this.performanceMarks.delete(label),duration&gt;threshold&amp;&amp;"undefined"!=typeof window&amp;&amp;window.performance&amp;&amp;window.performance.measure)try{performance.mark(`${label}-end`),performance.measure(label,`${label}-start`,`${label}-end`)}catch(e){}return duration}async buildIndex(siteId,points){const cacheKey=`index-${siteId}`;if(this.indexBuildPromises.has(cacheKey))return this.indexBuildPromises.get(cacheKey);const buildPromise=this.performIndexBuild(points);this.indexBuildPromises.set(cacheKey,buildPromise);try{const index=await buildPromise;return this.indexes.set(cacheKey,index),index}finally{this.indexBuildPromises.delete(cacheKey)}}async performIndexBuild(points){this.startMeasure("index-build");const index={byName:new Map,byId:new Map,byTag:new Map,byDescription:new Map,points:points,lastBuilt:Date.now()};for(let i=0;i&lt;points.length;i+=this.CHUNK_SIZE){const chunk=points.slice(i,Math.min(i+this.CHUNK_SIZE,points.length));await this.processChunk(chunk,i,index),i+this.CHUNK_SIZE&lt;points.length&amp;&amp;await new Promise(resolve=&gt;setTimeout(resolve,0))}return this.endMeasure("index-build",500),index}async processChunk(chunk,startIndex,index){return new Promise(resolve=&gt;{const processPoints=()=&gt;{chunk.forEach((point,i)=&gt;{const pointIndex=startIndex+i;if(point.name){this.tokenize(point.name).forEach(token=&gt;{index.byName.has(token)||index.byName.set(token,new Set),index.byName.get(token).add(pointIndex)})}if(point.id){this.tokenize(point.id.toString()).forEach(token=&gt;{index.byId.has(token)||index.byId.set(token,new Set),index.byId.get(token).add(pointIndex)})}if(point.marker_tags&amp;&amp;point.marker_tags.forEach(tag=&gt;{const lowerTag=tag.toLowerCase();index.byTag.has(lowerTag)||index.byTag.set(lowerTag,new Set),index.byTag.get(lowerTag).add(pointIndex)}),point.description){point.description.toLowerCase().split(/\s+/).slice(0,10).forEach(word=&gt;{word.length&gt;=3&amp;&amp;(index.byDescription.has(word)||index.byDescription.set(word,new Set),index.byDescription.get(word).add(pointIndex))})}}),resolve()};"requestIdleCallback"in window?window.requestIdleCallback(processPoints,{timeout:50}):processPoints()})}tokenize(str){const lower=str.toLowerCase(),tokens=new Set;if(tokens.add(lower),lower.length&lt;=20)for(let i=this.MIN_SEARCH_LENGTH;i&lt;lower.length&amp;&amp;i&lt;=10;i++)tokens.add(lower.substring(0,i));return lower.split(/[_\-\s\.\/]+/).forEach(word=&gt;{if(word.length&gt;=this.MIN_SEARCH_LENGTH&amp;&amp;(tokens.add(word),word.length&lt;=10))for(let i=this.MIN_SEARCH_LENGTH;i&lt;word.length;i++)tokens.add(word.substring(0,i))}),Array.from(tokens)}async search(siteId,points,query2,markerTags=[]){if(this.startMeasure("search-total"),!query2||query2.length&lt;this.MIN_SEARCH_LENGTH){if(markerTags.length&gt;0){return{points:points.filter(p=&gt;p.marker_tags&amp;&amp;markerTags.some(tag=&gt;p.marker_tags.includes(tag))),searchTime:this.endMeasure("search-total"),fromIndex:!1}}return{points:points,searchTime:this.endMeasure("search-total"),fromIndex:!1}}const cacheKey=`index-${siteId}`;let index=this.indexes.get(cacheKey);(!index||Date.now()-index.lastBuilt&gt;this.INDEX_TTL||index.points.length!==points.length)&amp;&amp;(index=await this.buildIndex(siteId,points)),this.startMeasure("index-search");const searchToken=query2.toLowerCase(),matchedIndices=new Set;index.byName.forEach((indices,token)=&gt;{(token.includes(searchToken)||searchToken.includes(token))&amp;&amp;indices.forEach(i=&gt;matchedIndices.add(i))}),index.byId.forEach((indices,token)=&gt;{(token.includes(searchToken)||searchToken.includes(token))&amp;&amp;indices.forEach(i=&gt;matchedIndices.add(i))}),index.byTag.forEach((indices,token)=&gt;{token.includes(searchToken)&amp;&amp;indices.forEach(i=&gt;matchedIndices.add(i))}),matchedIndices.size&lt;100&amp;&amp;index.byDescription.forEach((indices,token)=&gt;{token.includes(searchToken)&amp;&amp;indices.forEach(i=&gt;matchedIndices.add(i))}),this.endMeasure("index-search"),this.startMeasure("collect-results");let results=Array.from(matchedIndices).map(i=&gt;index.points[i]).filter(Boolean);markerTags.length&gt;0&amp;&amp;(results=results.filter(p=&gt;p.marker_tags&amp;&amp;markerTags.some(tag=&gt;p.marker_tags.includes(tag)))),results.sort((a,b)=&gt;{const aNameMatch=a.name.toLowerCase().startsWith(searchToken)?0:1,bNameMatch=b.name.toLowerCase().startsWith(searchToken)?0:1;return aNameMatch!==bNameMatch?aNameMatch-bNameMatch:a.name.localeCompare(b.name)}),this.endMeasure("collect-results");return{points:results,searchTime:this.endMeasure("search-total"),fromIndex:!0}}clearIndex(siteId){siteId?this.indexes.delete(`index-${siteId}`):this.indexes.clear()}getIndexStats(siteId){const index=this.indexes.get(`index-${siteId}`);return index?{pointCount:index.points.length,nameTokens:index.byName.size,idTokens:index.byId.size,tagTokens:index.byTag.size,descTokens:index.byDescription.size,age:Date.now()-index.lastBuilt,isStale:Date.now()-index.lastBuilt&gt;this.INDEX_TTL}:null}};const pointDataService=new class OptimizedPointServiceV2{constructor(){__publicField(this,"db",null),__publicField(this,"memoryCache",new Map),__publicField(this,"CACHE_TTL",18e5),__publicField(this,"MAX_MEMORY_CACHE",10),__publicField(this,"MAX_INDEXEDDB_SIZE",104857600),__publicField(this,"loadingPromises",new Map),__publicField(this,"cacheMetrics",{totalPoints:0,totalSites:0,cacheHits:0,cacheMisses:0,hitRate:0,lastCleanup:Date.now()}),__publicField(this,"usagePatterns",new Map),__publicField(this,"prefetchQueue",new Set),__publicField(this,"prefetchWorker",null),this.initIndexedDB(),this.startCleanupWorker(),this.loadCacheMetrics()}async initIndexedDB(){if("indexedDB"in window)try{const request=indexedDB.open("building-vitals-cache",2);request.onerror=()=&gt;{console.error("Failed to open IndexedDB:",request.error)},request.onsuccess=()=&gt;{this.db=request.result,console.log("✅ IndexedDB initialized"),this.loadUsagePatterns()},request.onupgradeneeded=event=&gt;{const db2=event.target.result;if(!db2.objectStoreNames.contains("points")){db2.createObjectStore("points",{keyPath:"siteId"}).createIndex("timestamp","timestamp",{unique:!1})}if(db2.objectStoreNames.contains("metadata")||db2.createObjectStore("metadata",{keyPath:"id"}),!db2.objectStoreNames.contains("usage")){const usageStore=db2.createObjectStore("usage",{keyPath:"siteId"});usageStore.createIndex("accessCount","accessCount",{unique:!1}),usageStore.createIndex("lastAccessed","lastAccessed",{unique:!1})}}}catch(error){console.error("IndexedDB initialization failed:",error)}else console.warn("IndexedDB not supported, falling back to memory cache")}async loadPoints(options){const{siteId:siteId,page:page=1,pageSize:pageSize=1e5,searchQuery:searchQuery="",markerTags:markerTags=[],collectEnabledOnly:collectEnabledOnly=!1,useCache:useCache=!0,enableIndexedDB:enableIndexedDB=!0,sortBy:sortBy="name",sortOrder:sortOrder="asc"}=options,startTime=performance.now();if(this.trackUsage(siteId),useCache){const cached=await this.getFromCache(siteId,enableIndexedDB);if(cached){this.recordCacheHit();const filtered=this.filterAndSort(cached,searchQuery,markerTags,sortBy,sortOrder),loadTime=performance.now()-startTime;return this.paginateResults(filtered,page,pageSize,!0,loadTime)}}const loadingKey=`${siteId}-${searchQuery}`;if(this.loadingPromises.has(loadingKey)){const points=await this.loadingPromises.get(loadingKey),loadTime=performance.now()-startTime;return this.paginateResults(points,page,pageSize,!1,loadTime)}this.recordCacheMiss();const loadPromise=this.loadFromAPI(siteId,collectEnabledOnly);this.loadingPromises.set(loadingKey,loadPromise);try{const allPoints=await loadPromise;useCache&amp;&amp;await this.addToCache(siteId,allPoints,enableIndexedDB);const filtered=this.filterAndSort(allPoints,searchQuery,markerTags,sortBy,sortOrder);this.prefetchPredictedSites(siteId);const loadTime=performance.now()-startTime;return this.paginateResults(filtered,page,pageSize,!1,loadTime)}finally{this.loadingPromises.delete(loadingKey)}}async getFromIndexedDB(siteId){if(!this.db)return null;try{return new Promise((resolve,reject)=&gt;{const request=this.db.transaction(["points"],"readonly").objectStore("points").get(siteId);request.onsuccess=()=&gt;{const data=request.result;data&amp;&amp;Date.now()-data.timestamp&lt;this.CACHE_TTL?resolve(data):resolve(null)},request.onerror=()=&gt;reject(request.error)})}catch(error){return console.error("IndexedDB read failed:",error),null}}async prefetchSite(siteId){if(this.prefetchQueue.has(siteId))return;this.prefetchQueue.add(siteId);await this.getFromCache(siteId,!0)?this.prefetchQueue.delete(siteId):requestIdleCallback(async()=&gt;{try{await this.loadPoints({siteId:siteId,useCache:!0,enableIndexedDB:!0})}catch(error){console.error(`Prefetch failed for ${siteId}:`,error)}finally{this.prefetchQueue.delete(siteId)}})}getPredictedSites(currentSiteId){const pattern=this.usagePatterns.get(currentSiteId);return(null==pattern?void 0:pattern.nextPredicted)?pattern.nextPredicted:this.getMostFrequentSites(3)}async clearCache(siteId){siteId?(this.memoryCache.delete(siteId),this.db&amp;&amp;await this.deleteFromIndexedDB(siteId)):(this.memoryCache.clear(),this.db&amp;&amp;await this.clearAllIndexedDB())}async clearAllCaches(siteId){await this.clearCache(siteId),pointSearchOptimizer.clearIndex(siteId)}getCacheStats(){return{entries:this.memoryCache.size,totalPoints:this.cacheMetrics.totalPoints,hitRate:this.cacheMetrics.hitRate,cacheSize:this.estimateCacheSize(),predictedSites:this.getMostFrequentSites(5)}}async loadFromAPI(siteId,collectEnabledOnly){var _a,_b;try{const aceToken=store.getState().auth.aceToken;console.log(`🔍 [OptimizedPointServiceV2] Loading points for site: ${siteId}, collect_enabled: ${collectEnabledOnly}`),aceToken&amp;&amp;cloudflareWorkerClient.setToken(aceToken);let points=[];try{const response=await cloudflareWorkerClient.getPoints(siteId,collectEnabledOnly);console.log(`🔍 [OptimizedPointServiceV2] Raw API response for site ${siteId}:`,{hasResponse:!!response,responseType:typeof response,isArray:Array.isArray(response),hasItems:!!(null==response?void 0:response.items),itemsLength:(null==(_a=null==response?void 0:response.items)?void 0:_a.length)||0,total:(null==response?void 0:response.total)||0,pages:(null==response?void 0:response.pages)||0,allPagesLoaded:(null==response?void 0:response.allPagesLoaded)||!1,sampleData:(null==(_b=null==response?void 0:response.items)?void 0:_b[0])||(null==response?void 0:response[0])||"No data"}),(null==response?void 0:response.items)&amp;&amp;Array.isArray(response.items)?points=response.items:Array.isArray(response)?points=response:(console.error("❌ Unexpected response format:",response),points=[])}catch(apiError){throw console.error(`❌ [OptimizedPointServiceV2] API call failed for site ${siteId}:`,{error:apiError.message,status:apiError.status,details:apiError}),new Error(`Failed to fetch points for site ${siteId}: ${apiError.message||"Unknown error"}`)}if(console.log(`📊 [OptimizedPointServiceV2] Loaded ${points.length} points from API for site: ${siteId}`),0===points.length?console.warn(`⚠️ [OptimizedPointServiceV2] No points returned for site ${siteId}. Possible reasons:\n          1. The site has no collect-enabled points configured in ACE IoT\n          2. The /configured_points endpoint returned empty\n          3. There might be an authentication or permission issue`):console.log("🔍 [OptimizedPointServiceV2] Sample point structure:",points[0]),collectEnabledOnly&amp;&amp;points.length&gt;0){const beforeFilter=points.length;points=points.filter(p=&gt;!1!==p.collect_enabled),beforeFilter!==points.length&amp;&amp;console.log(`🔽 [OptimizedPointServiceV2] Filtered from ${beforeFilter} to ${points.length} collect-enabled points`)}return points}catch(error){throw console.error("API load failed:",error),error}}filterAndSort(points,searchQuery,markerTags,sortBy,sortOrder){let filtered=[...points];if(searchQuery){const query2=searchQuery.toLowerCase();filtered=filtered.filter(p=&gt;{var _a,_b,_c;return(null==(_a=p.name)?void 0:_a.toLowerCase().includes(query2))||(null==(_b=p.id)?void 0:_b.toLowerCase().includes(query2))||(null==(_c=p.marker_tags)?void 0:_c.some(tag=&gt;tag.toLowerCase().includes(query2)))})}return markerTags.length&gt;0&amp;&amp;(filtered=filtered.filter(p=&gt;markerTags.some(tag=&gt;{var _a;return null==(_a=p.marker_tags)?void 0:_a.includes(tag)}))),filtered.sort((a,b)=&gt;{let comparison=0;switch(sortBy){case"name":comparison=a.name.localeCompare(b.name);break;case"type":comparison=(a.type||"").localeCompare(b.type||"")}return"asc"===sortOrder?comparison:-comparison}),filtered}paginateResults(points,page,pageSize,fromCache,loadTime){const totalCount=points.length;if(pageSize&gt;=1e5)return{points:points,totalCount:totalCount,page:1,pageSize:totalCount,hasMore:!1,fromCache:fromCache,loadTime:loadTime};const start=(page-1)*pageSize,end=start+pageSize;return{points:points.slice(start,end),totalCount:totalCount,page:page,pageSize:pageSize,hasMore:end&lt;totalCount,fromCache:fromCache,loadTime:loadTime}}async getFromCache(siteId,useIndexedDB){const memCached=this.memoryCache.get(siteId);if(memCached&amp;&amp;Date.now()-memCached.timestamp&lt;this.CACHE_TTL)return console.log(`📦 [OptimizedPointServiceV2] Found ${memCached.points.length} points in memory cache for site: ${siteId}`),memCached.points;if(useIndexedDB&amp;&amp;this.db){const dbCached=await this.getFromIndexedDB(siteId);if(dbCached)return console.log(`💿 [OptimizedPointServiceV2] Found ${dbCached.points.length} points in IndexedDB for site: ${siteId}`),this.memoryCache.set(siteId,dbCached),dbCached.points}return console.log(`❌ [OptimizedPointServiceV2] No cache found for site: ${siteId}`),null}async addToCache(siteId,points,useIndexedDB){console.log(`💾 [OptimizedPointServiceV2] Caching ${points.length} points for site: ${siteId}`);const cache={siteId:siteId,points:points,timestamp:Date.now(),version:"2.0"};if(this.memoryCache.size&gt;=this.MAX_MEMORY_CACHE){const oldest=Array.from(this.memoryCache.entries()).sort(([,a],[,b])=&gt;a.timestamp-b.timestamp)[0];oldest&amp;&amp;(console.log(`🗑️ [OptimizedPointServiceV2] Evicting oldest cache entry for site: ${oldest[0]}`),this.memoryCache.delete(oldest[0]))}this.memoryCache.set(siteId,cache),useIndexedDB&amp;&amp;this.db&amp;&amp;(await this.saveToIndexedDB(cache),console.log(`💿 [OptimizedPointServiceV2] Saved ${points.length} points to IndexedDB for site: ${siteId}`)),this.cacheMetrics.totalPoints=points.length,this.cacheMetrics.totalSites=this.memoryCache.size}async saveToIndexedDB(cache){if(this.db)return new Promise((resolve,reject)=&gt;{const request=this.db.transaction(["points"],"readwrite").objectStore("points").put(cache);request.onsuccess=()=&gt;resolve(),request.onerror=()=&gt;reject(request.error)})}async deleteFromIndexedDB(siteId){if(this.db)return new Promise((resolve,reject)=&gt;{const request=this.db.transaction(["points"],"readwrite").objectStore("points").delete(siteId);request.onsuccess=()=&gt;resolve(),request.onerror=()=&gt;reject(request.error)})}async clearAllIndexedDB(){if(this.db)return new Promise((resolve,reject)=&gt;{const request=this.db.transaction(["points"],"readwrite").objectStore("points").clear();request.onsuccess=()=&gt;resolve(),request.onerror=()=&gt;reject(request.error)})}trackUsage(siteId){const existing=this.usagePatterns.get(siteId)||{siteId:siteId,accessCount:0,lastAccessed:Date.now(),averageLoadTime:0};existing.accessCount++,existing.lastAccessed=Date.now(),this.usagePatterns.set(siteId,existing),this.saveUsagePattern(existing)}async saveUsagePattern(pattern){if(this.db)try{const transaction=this.db.transaction(["usage"],"readwrite");transaction.objectStore("usage").put(pattern)}catch(error){console.error("Failed to save usage pattern:",error)}}async loadUsagePatterns(){if(this.db)try{const transaction=this.db.transaction(["usage"],"readonly"),request=transaction.objectStore("usage").getAll();request.onsuccess=()=&gt;{request.result.forEach(p=&gt;this.usagePatterns.set(p.siteId,p))}}catch(error){console.error("Failed to load usage patterns:",error)}}getMostFrequentSites(limit){return Array.from(this.usagePatterns.entries()).sort(([,a],[,b])=&gt;b.accessCount-a.accessCount).slice(0,limit).map(([siteId])=&gt;siteId)}prefetchPredictedSites(currentSiteId){this.getPredictedSites(currentSiteId).forEach(siteId=&gt;{setTimeout(()=&gt;this.prefetchSite(siteId),2e3)})}recordCacheHit(){this.cacheMetrics.cacheHits++,this.updateHitRate()}recordCacheMiss(){this.cacheMetrics.cacheMisses++,this.updateHitRate()}updateHitRate(){const total=this.cacheMetrics.cacheHits+this.cacheMetrics.cacheMisses;this.cacheMetrics.hitRate=total&gt;0?this.cacheMetrics.cacheHits/total:0,this.saveCacheMetrics()}async saveCacheMetrics(){if(this.db)try{const transaction=this.db.transaction(["metadata"],"readwrite");transaction.objectStore("metadata").put({...this.cacheMetrics,id:"metrics"})}catch(error){console.error("Failed to save cache metrics:",error)}}async loadCacheMetrics(){if(this.db)try{const transaction=this.db.transaction(["metadata"],"readonly"),request=transaction.objectStore("metadata").get("metrics");request.onsuccess=()=&gt;{request.result&amp;&amp;(this.cacheMetrics=request.result)}}catch(error){console.error("Failed to load cache metrics:",error)}}estimateCacheSize(){let size=0;return this.memoryCache.forEach(cache=&gt;{size+=JSON.stringify(cache).length}),size}startCleanupWorker(){setInterval(()=&gt;this.cleanupOldCache(),36e5)}async cleanupOldCache(){const now=Date.now(),toDelete=[];if(this.memoryCache.forEach((cache,siteId)=&gt;{now-cache.timestamp&gt;this.CACHE_TTL&amp;&amp;toDelete.push(siteId)}),toDelete.forEach(siteId=&gt;this.memoryCache.delete(siteId)),this.db){const store2=this.db.transaction(["points"],"readwrite").objectStore("points"),index=store2.index("timestamp"),range=IDBKeyRange.upperBound(now-this.CACHE_TTL),request=index.openCursor(range);request.onsuccess=()=&gt;{const cursor=request.result;cursor&amp;&amp;(store2.delete(cursor.primaryKey),cursor.continue())}}this.cacheMetrics.lastCleanup=now,console.log(`🧹 Cache cleanup completed, removed ${toDelete.length} entries`)}};class PointCacheService{constructor(){__publicField(this,"dbName","BuildingVitalsCache"),__publicField(this,"version",1),__publicField(this,"storeName","points"),__publicField(this,"db",null),__publicField(this,"DEFAULT_TTL",3e5),__publicField(this,"MAX_CACHE_SIZE",52428800),__publicField(this,"stats",{entries:0,totalSize:0,hits:0,misses:0,hitRate:0})}async initialize(){return new Promise((resolve,reject)=&gt;{const request=indexedDB.open(this.dbName,this.version);request.onerror=()=&gt;{console.error("[PointCacheService] Failed to open IndexedDB:",request.error),reject(request.error)},request.onsuccess=()=&gt;{this.db=request.result,console.log("[PointCacheService] IndexedDB initialized successfully"),this.loadStats(),resolve()},request.onupgradeneeded=event=&gt;{const db2=event.target.result;if(!db2.objectStoreNames.contains(this.storeName)){const store2=db2.createObjectStore(this.storeName,{keyPath:"id"});store2.createIndex("timestamp","timestamp",{unique:!1}),store2.createIndex("size","size",{unique:!1})}}})}async get(key){return this.db||await this.initialize(),new Promise((resolve,reject)=&gt;{const request=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(key);request.onerror=()=&gt;{console.error("[PointCacheService] Failed to get from cache:",request.error),this.stats.misses++,resolve(null)},request.onsuccess=()=&gt;{const entry=request.result;return entry?Date.now()-entry.timestamp&gt;entry.ttl?(this.stats.misses++,this.remove(key),void resolve(null)):(this.stats.hits++,this.updateHitRate(),void resolve(entry.data)):(this.stats.misses++,void resolve(null))}})}async set(key,data,ttl=this.DEFAULT_TTL){this.db||await this.initialize();const serializedData=JSON.stringify(data),size=new Blob([serializedData]).size;this.stats.totalSize+size&gt;this.MAX_CACHE_SIZE&amp;&amp;await this.evictOldEntries(size);const entry={id:key,data:data,timestamp:Date.now(),ttl:ttl,size:size};return new Promise((resolve,reject)=&gt;{const request=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(entry);request.onerror=()=&gt;{console.error("[PointCacheService] Failed to set cache:",request.error),reject(request.error)},request.onsuccess=()=&gt;{this.stats.entries++,this.stats.totalSize+=size,resolve()}})}async remove(key){return this.db||await this.initialize(),new Promise((resolve,reject)=&gt;{const store2=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName),getRequest=store2.get(key);getRequest.onsuccess=()=&gt;{const entry=getRequest.result,deleteRequest=store2.delete(key);deleteRequest.onerror=()=&gt;{console.error("[PointCacheService] Failed to remove from cache:",deleteRequest.error),reject(deleteRequest.error)},deleteRequest.onsuccess=()=&gt;{entry&amp;&amp;(this.stats.entries=Math.max(0,this.stats.entries-1),this.stats.totalSize=Math.max(0,this.stats.totalSize-entry.size)),resolve()}},getRequest.onerror=()=&gt;{console.error("[PointCacheService] Failed to get entry for removal:",getRequest.error),reject(getRequest.error)}})}async clear(){return this.db||await this.initialize(),new Promise((resolve,reject)=&gt;{const request=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();request.onerror=()=&gt;{console.error("[PointCacheService] Failed to clear cache:",request.error),reject(request.error)},request.onsuccess=()=&gt;{this.stats={entries:0,totalSize:0,hits:this.stats.hits,misses:this.stats.misses,hitRate:this.stats.hitRate},console.log("[PointCacheService] Cache cleared successfully"),resolve()}})}async cleanup(){return this.db||await this.initialize(),new Promise((resolve,reject)=&gt;{const request=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).openCursor();let deletedCount=0;request.onerror=()=&gt;{console.error("[PointCacheService] Failed to cleanup cache:",request.error),reject(request.error)},request.onsuccess=event=&gt;{const cursor=event.target.result;if(cursor){const entry=cursor.value;Date.now()-entry.timestamp&gt;entry.ttl&amp;&amp;(cursor.delete(),this.stats.entries=Math.max(0,this.stats.entries-1),this.stats.totalSize=Math.max(0,this.stats.totalSize-entry.size),deletedCount++),cursor.continue()}else console.log(`[PointCacheService] Cleanup completed: ${deletedCount} expired entries removed`),resolve(deletedCount)}})}getStats(){return{...this.stats}}static isSupported(){return"undefined"!=typeof indexedDB}async loadStats(){if(this.db)return new Promise(resolve=&gt;{const request=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).openCursor();let entries=0,totalSize=0;request.onsuccess=event=&gt;{const cursor=event.target.result;if(cursor){const entry=cursor.value;entries++,totalSize+=entry.size,cursor.continue()}else this.stats.entries=entries,this.stats.totalSize=totalSize,resolve()},request.onerror=()=&gt;{console.error("[PointCacheService] Failed to load stats"),resolve()}})}updateHitRate(){const total=this.stats.hits+this.stats.misses;this.stats.hitRate=total&gt;0?this.stats.hits/total:0}async evictOldEntries(neededSpace){if(this.db)return new Promise((resolve,reject)=&gt;{const request=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).index("timestamp").openCursor();let freedSpace=0,deletedCount=0;request.onerror=()=&gt;{console.error("[PointCacheService] Failed to evict entries:",request.error),reject(request.error)},request.onsuccess=event=&gt;{const cursor=event.target.result;if(cursor&amp;&amp;freedSpace&lt;neededSpace){const entry=cursor.value;cursor.delete(),freedSpace+=entry.size,deletedCount++,this.stats.entries=Math.max(0,this.stats.entries-1),this.stats.totalSize=Math.max(0,this.stats.totalSize-entry.size),cursor.continue()}else console.log(`[PointCacheService] Evicted ${deletedCount} entries, freed ${freedSpace} bytes`),resolve()}})}}const pointCacheService=new PointCacheService;PointCacheService.isSupported()&amp;&amp;(pointCacheService.initialize().catch(error=&gt;{console.warn("[PointCacheService] Failed to initialize IndexedDB, falling back to memory cache:",error)}),setInterval(()=&gt;{pointCacheService.cleanup().catch(error=&gt;{console.warn("[PointCacheService] Cleanup failed:",error)})},6e5));let logger$1=null;const getLogger$1=()=&gt;(logger$1||(logger$1=createLogger("SiteTrackingService")),logger$1);const siteTrackingService=new class SiteTrackingService{constructor(){__publicField(this,"STORAGE_KEY","siteUsageTracking"),__publicField(this,"MAX_TRACKED_SITES",20),__publicField(this,"USAGE_EXPIRY",2592e6)}trackSiteAccess(siteId,siteName){try{const usage=this.getUsageData(),existing=usage.find(u=&gt;u.siteId===siteId);existing?(existing.lastAccessed=Date.now(),existing.accessCount++,siteName&amp;&amp;(existing.siteName=siteName)):usage.push({siteId:siteId,siteName:siteName,lastAccessed:Date.now(),accessCount:1}),usage.sort((a,b)=&gt;b.lastAccessed-a.lastAccessed);const filtered=usage.slice(0,this.MAX_TRACKED_SITES).filter(u=&gt;Date.now()-u.lastAccessed&lt;this.USAGE_EXPIRY);this.saveUsageData(filtered),getLogger$1().debug(`Tracked access to site ${siteId}`,{accessCount:existing?existing.accessCount+1:1})}catch(error){getLogger$1().error("Failed to track site access",error)}}getRecentSites(limit){try{const scored=this.getUsageData().map(u=&gt;({...u,score:this.calculateScore(u)}));scored.sort((a,b)=&gt;b.score-a.score);const sites=scored.map(u=&gt;u.siteId);return limit?sites.slice(0,limit):sites}catch(error){return getLogger$1().error("Failed to get recent sites",error),[]}}getFrequentSites(limit=5){try{const usage=this.getUsageData();return usage.sort((a,b)=&gt;b.accessCount-a.accessCount),usage.slice(0,limit).map(u=&gt;u.siteId)}catch(error){return getLogger$1().error("Failed to get frequent sites",error),[]}}getUsageStats(){try{const usage=this.getUsageData();if(0===usage.length)return{totalSites:0,totalAccesses:0,mostUsed:null,lastUsed:null};const totalAccesses=usage.reduce((sum,u)=&gt;sum+u.accessCount,0),mostUsed=[...usage].sort((a,b)=&gt;b.accessCount-a.accessCount)[0],lastUsed=[...usage].sort((a,b)=&gt;b.lastAccessed-a.lastAccessed)[0];return{totalSites:usage.length,totalAccesses:totalAccesses,mostUsed:mostUsed,lastUsed:lastUsed}}catch(error){return getLogger$1().error("Failed to get usage stats",error),{totalSites:0,totalAccesses:0,mostUsed:null,lastUsed:null}}}clearTracking(){try{localStorage.removeItem(this.STORAGE_KEY),getLogger$1().info("Cleared all site tracking data")}catch(error){getLogger$1().error("Failed to clear tracking data",error)}}calculateScore(usage){const ageInDays=(Date.now()-usage.lastAccessed)/864e5;return.7*Math.exp(-ageInDays/7)+.3*(Math.log(usage.accessCount+1)/Math.log(10))}getUsageData(){try{const stored=localStorage.getItem(this.STORAGE_KEY);if(!stored)return[];const data=JSON.parse(stored);return Array.isArray(data)?data.filter(item=&gt;item&amp;&amp;"string"==typeof item.siteId&amp;&amp;"number"==typeof item.lastAccessed&amp;&amp;"number"==typeof item.accessCount):(getLogger$1().warn("Invalid usage data format, resetting"),[])}catch(error){return getLogger$1().error("Failed to parse usage data",error),[]}}saveUsageData(data){try{localStorage.setItem(this.STORAGE_KEY,JSON.stringify(data))}catch(error){if(getLogger$1().error("Failed to save usage data",error),"QuotaExceededError"===error.name){getLogger$1().warn("Storage quota exceeded, clearing old tracking data"),this.clearTracking();try{const recent=data.slice(0,5);localStorage.setItem(this.STORAGE_KEY,JSON.stringify(recent))}catch(retryError){getLogger$1().error("Failed to save even minimal tracking data",retryError)}}}}};let logger=null;const getLogger=()=&gt;(logger||(logger=createLogger("PointPreloadService")),logger);const pointPreloadService=new class PointPreloadService{constructor(){__publicField(this,"isPreloading",!1),__publicField(this,"preloadPromise",null),__publicField(this,"progress",{totalSites:0,loadedSites:0,totalPoints:0,status:"idle",errors:[]}),__publicField(this,"abortController",null),__publicField(this,"preloadStartTime",0)}async startPreloading(aceToken,options={}){const{priority:priority="all",maxConcurrent:maxConcurrent=3,onProgress:onProgress}=options;return this.isPreloading&amp;&amp;this.preloadPromise?(getLogger().info("Preloading already in progress, returning existing promise"),this.preloadPromise):(getLogger().info("Starting point preloading",{priority:priority,maxConcurrent:maxConcurrent}),this.isPreloading=!0,this.preloadStartTime=Date.now(),this.abortController=new AbortController,this.progress={totalSites:0,loadedSites:0,totalPoints:0,status:"loading",errors:[]},null==onProgress||onProgress(this.progress),this.preloadPromise=this.performPreload(aceToken,priority,maxConcurrent,onProgress).finally(()=&gt;{this.isPreloading=!1,this.preloadPromise=null;const duration=Date.now()-this.preloadStartTime;getLogger().info("Preloading completed",{duration:`${(duration/1e3).toFixed(2)}s`,totalSites:this.progress.totalSites,totalPoints:this.progress.totalPoints,errors:this.progress.errors.length})}),this.preloadPromise)}stopPreloading(){this.abortController&amp;&amp;(getLogger().info("Stopping preloading"),this.abortController.abort(),this.abortController=null)}getProgress(){return{...this.progress}}isLoading(){return this.isPreloading}async clearPreloadedData(){getLogger().info("Clearing all preloaded data"),await pointDataService.clearCache(),await pointCacheService.clear(),pointSearchOptimizer.clearIndex()}async performPreload(aceToken,priority,maxConcurrent,onProgress){try{getLogger().debug("Fetching all sites");const sites=await this.fetchSites(aceToken);if(!sites||0===sites.length)return getLogger().warn("No sites found to preload"),this.progress.status="complete",void(null==onProgress||onProgress(this.progress));this.progress.totalSites=sites.length,null==onProgress||onProgress(this.progress);const prioritizedSites=this.prioritizeSites(sites,priority);await this.loadSitesWithConcurrency(prioritizedSites,aceToken,maxConcurrent,onProgress),getLogger().debug("Warming up search indexes"),await this.warmUpSearchIndexes(prioritizedSites),this.progress.status="complete",null==onProgress||onProgress(this.progress),this.scheduleRefresh(aceToken)}catch(error){throw getLogger().error("Preloading failed",error),this.progress.status="error",this.progress.errors.push(error.message||"Unknown error"),null==onProgress||onProgress(this.progress),error}}async fetchSites(aceToken){try{const sites=await aceIotApiClient.getSites(aceToken);return getLogger().debug(`Fetched ${sites.length} sites`),sites}catch(error){throw getLogger().error("Failed to fetch sites",error),error}}prioritizeSites(sites,priority){if("recent"===priority){const recentSiteIds=siteTrackingService.getRecentSites(),recentSet=new Set(recentSiteIds);return[...sites.filter(s=&gt;recentSet.has(s.id)),...sites.filter(s=&gt;!recentSet.has(s.id))]}return sites}async loadSitesWithConcurrency(sites,aceToken,maxConcurrent,onProgress){var _a;const queue=[...sites],inProgress=new Set;for(;queue.length&gt;0||inProgress.size&gt;0;){if(null==(_a=this.abortController)?void 0:_a.signal.aborted){getLogger().info("Preloading cancelled");break}for(;inProgress.size&lt;maxConcurrent&amp;&amp;queue.length&gt;0;){const site=queue.shift(),loadPromise=this.loadSitePoints(site,aceToken).then(()=&gt;{this.progress.loadedSites++,null==onProgress||onProgress(this.progress)}).finally(()=&gt;{inProgress.delete(loadPromise)});inProgress.add(loadPromise)}inProgress.size&gt;0&amp;&amp;await Promise.race(inProgress)}await Promise.all(inProgress)}async loadSitePoints(site,aceToken){getLogger().debug(`Loading points for site: ${site.id}`),this.progress.currentSite=site.id;try{const response=await pointDataService.loadPoints({siteId:site.id,page:1,pageSize:1e5,useCache:!0});this.progress.totalPoints+=response.totalCount,getLogger().debug(`Loaded ${response.totalCount} points for site ${site.id}`),await this.preloadCommonTagCombinations(site.id)}catch(error){getLogger().error(`Failed to load points for site ${site.id}`,error),this.progress.errors.push(`Site ${site.id}: ${error.message||"Unknown error"}`)}}async preloadCommonTagCombinations(siteId){Promise.all([["temp","sensor"],["humidity","sensor"],["pressure","sensor"],["flow","sensor"],["power","meter"],["energy","meter"],["setpoint"],["status"],["oat"],["mat"],["rat"]].map(tags=&gt;pointDataService.getPointsByTags(siteId,tags).catch(error=&gt;{getLogger().debug(`Failed to preload tags ${tags.join(",")} for site ${siteId}`,error)}))).catch(()=&gt;{})}async warmUpSearchIndexes(sites){for(const site of sites)try{await pointSearchOptimizer.buildIndex(site.id)}catch(error){getLogger().debug(`Failed to build search index for site ${site.id}`,error)}}scheduleRefresh(aceToken){setTimeout(()=&gt;{var _a;(null==(_a=this.abortController)?void 0:_a.signal.aborted)||(getLogger().debug("Starting scheduled cache refresh"),this.startPreloading(aceToken,{priority:"recent",maxConcurrent:1}).catch(error=&gt;{getLogger().warn("Scheduled refresh failed",error)}))},18e5)}async getStats(){const cacheStats=pointDataService.getCacheStats();return{cachedSites:cacheStats.sites,totalPoints:cacheStats.totalPoints,cacheSize:cacheStats.entries,lastPreload:this.preloadStartTime||null}}},pointPreloadService$1=Object.freeze(Object.defineProperty({__proto__:null,pointPreloadService:pointPreloadService},Symbol.toStringTag,{value:"Module"})),_ErrorTrackingService=class _ErrorTrackingService{constructor(){__publicField(this,"breadcrumbs",[]),__publicField(this,"maxBreadcrumbs",50),__publicField(this,"context",{}),__publicField(this,"errorQueue",[]),__publicField(this,"isInitialized",!1),__publicField(this,"reportingEndpoint"),this.setupGlobalHandlers()}static getInstance(){return _ErrorTrackingService.instance||(_ErrorTrackingService.instance=new _ErrorTrackingService),_ErrorTrackingService.instance}initialize(config){this.reportingEndpoint=config.dsn,this.context.environment=config.environment||"production",this.context.release=config.release||"1.0.0",this.isInitialized=!0,this.processErrorQueue()}setUser(user){user?this.context.user=user:delete this.context.user}setTags(tags){this.context.tags={...this.context.tags,...tags}}setExtra(extra){this.context.extra={...this.context.extra,...extra}}addBreadcrumb(breadcrumb){this.breadcrumbs.push({...breadcrumb,timestamp:(new Date).toISOString()}),this.breadcrumbs.length&gt;this.maxBreadcrumbs&amp;&amp;(this.breadcrumbs=this.breadcrumbs.slice(-this.maxBreadcrumbs))}captureError(error,level="error",extra){const report={message:error.message,stack:error.stack,level:level,timestamp:(new Date).toISOString(),context:{...this.context,extra:{...this.context.extra,...extra}},breadcrumbs:[...this.breadcrumbs],fingerprint:this.generateFingerprint(error)};this.sendReport(report)}captureMessage(message,level="info",extra){const report={message:message,level:level,timestamp:(new Date).toISOString(),context:{...this.context,extra:{...this.context.extra,...extra}},breadcrumbs:[...this.breadcrumbs]};this.sendReport(report)}captureException(exception,context){let error;error=exception instanceof Error?exception:"string"==typeof exception?new Error(exception):new Error(JSON.stringify(exception));const report={message:error.message,stack:error.stack,level:(null==context?void 0:context.level)||"error",timestamp:(new Date).toISOString(),context:{...this.context,tags:{...this.context.tags,...null==context?void 0:context.tags},extra:{...this.context.extra,...null==context?void 0:context.extra}},breadcrumbs:[...this.breadcrumbs],fingerprint:this.generateFingerprint(error)};this.sendReport(report)}setupGlobalHandlers(){window.addEventListener("error",event=&gt;{this.addBreadcrumb({type:"error",category:"error",message:event.message,level:"error",data:{filename:event.filename,lineno:event.lineno,colno:event.colno}}),event.error?this.captureError(event.error):this.captureMessage(event.message,"error",{filename:event.filename,lineno:event.lineno,colno:event.colno})}),window.addEventListener("unhandledrejection",event=&gt;{this.addBreadcrumb({type:"error",category:"unhandledrejection",message:"Unhandled Promise Rejection",level:"error",data:{reason:event.reason}}),event.reason instanceof Error?this.captureError(event.reason):this.captureMessage(`Unhandled Promise Rejection: ${event.reason}`,"error",{reason:event.reason})});const originalConsoleError=console.error;if(console.error=(...args)=&gt;{this.addBreadcrumb({type:"console",category:"console",message:args.map(arg=&gt;String(arg)).join(" "),level:"error"}),originalConsoleError.apply(console,args)},window.history&amp;&amp;window.history.pushState){const originalPushState=window.history.pushState;window.history.pushState=(...args)=&gt;(this.addBreadcrumb({type:"navigation",category:"navigation",message:`Navigation to ${window.location.pathname}`}),originalPushState.apply(window.history,args))}}generateFingerprint(error){var _a;const fingerprint=[];fingerprint.push(error.name||"Error");const messagePattern=error.message.replace(/\b\d+\b/g,"N").replace(/["'][^"']*["']/g,"STR").substring(0,100);if(fingerprint.push(messagePattern),error.stack){const framePattern=((null==(_a=error.stack.split("\n")[1])?void 0:_a.trim())||"").replace(/:\d+:\d+/g,"").replace(/\?[^)]+/g,"");fingerprint.push(framePattern)}return fingerprint}async sendReport(report){if(this.isInitialized){if(this.reportingEndpoint)try{await fetch(this.reportingEndpoint,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(report)})}catch(error){}this.storeErrorLocally(report)}else this.errorQueue.push(report)}storeErrorLocally(report){try{const storedErrors=localStorage.getItem("errorReports")||"[]",errors=JSON.parse(storedErrors);errors.push(report);const recentErrors=errors.slice(-50);localStorage.setItem("errorReports",JSON.stringify(recentErrors))}catch(error){}}processErrorQueue(){const queue=[...this.errorQueue];this.errorQueue=[],queue.forEach(report=&gt;this.sendReport(report));try{const storedErrors=localStorage.getItem("errorReports");if(storedErrors){JSON.parse(storedErrors).forEach(report=&gt;this.sendReport(report)),localStorage.removeItem("errorReports")}}catch(error){}}wrap(fn,options){return(...args)=&gt;{try{const result=fn(...args);return result instanceof Promise?result.catch(error=&gt;{throw this.captureException(error,options),error}):result}catch(error){throw this.captureException(error,options),error}}}};__publicField(_ErrorTrackingService,"instance");const errorTracker=_ErrorTrackingService.getInstance();(null==errorTracker?void 0:errorTracker.captureError)&amp;&amp;errorTracker.captureError.bind(errorTracker),(null==errorTracker?void 0:errorTracker.captureMessage)&amp;&amp;errorTracker.captureMessage.bind(errorTracker),(null==errorTracker?void 0:errorTracker.captureException)&amp;&amp;errorTracker.captureException.bind(errorTracker),(null==errorTracker?void 0:errorTracker.addBreadcrumb)&amp;&amp;errorTracker.addBreadcrumb.bind(errorTracker);const setUser=(null==errorTracker?void 0:errorTracker.setUser)?errorTracker.setUser.bind(errorTracker):()=&gt;{};(null==errorTracker?void 0:errorTracker.setTags)&amp;&amp;errorTracker.setTags.bind(errorTracker),(null==errorTracker?void 0:errorTracker.setExtra)&amp;&amp;errorTracker.setExtra.bind(errorTracker),(null==errorTracker?void 0:errorTracker.wrap)&amp;&amp;errorTracker.wrap.bind(errorTracker);function getDefaultToken(siteId="ses_falls_city"){return getTokenForSite(siteId)}class TokenResolver{constructor(){__publicField(this,"cache",new Map),__publicField(this,"CACHE_TTL",3e5),__publicField(this,"eventListeners",new Map)}async resolveToken(siteId){const startTime=performance.now(),cached=this.getCached(siteId);if(cached)return console.debug(`[TokenResolver] Token resolved from cache for ${siteId} (${cached.source})`),cached.token;const token=await this.resolveFromChain(siteId);if(token){const source=this.determineSource(siteId,token);this.cache.set(siteId,{token:token,timestamp:Date.now(),source:source,siteId:siteId})}const resolutionTime=performance.now()-startTime;return console.debug(`[TokenResolver] Token resolution for ${siteId} took ${resolutionTime.toFixed(2)}ms`),token}async resolveFromChain(siteId){const defaultToken=getDefaultToken(siteId);if(defaultToken)return console.debug(`[TokenResolver] Token resolved: default for ${siteId}`),defaultToken;const globalToken=this.getGlobalToken();return globalToken?(console.debug(`[TokenResolver] Token resolved: global fallback for ${siteId}`),globalToken):(console.warn(`[TokenResolver] No token available for site: ${siteId}`),this.emit("tokenMissing",{siteId:siteId}),null)}getCached(siteId){const cached=this.cache.get(siteId);if(!cached)return null;return Date.now()-cached.timestamp&gt;this.CACHE_TTL?(this.cache.delete(siteId),null):cached}getGlobalToken(){const aceToken=function getAceApiToken(){try{return localStorage.getItem("ace_api_token")}catch(error){return console.error("[AceTokenHelpers] Failed to read token from localStorage:",error),null}}();if(aceToken)return aceToken;try{const stored=localStorage.getItem("ace_token");if(stored)return stored}catch(error){console.warn("[TokenResolver] Failed to read from localStorage:",error)}try{const stored=sessionStorage.getItem("ace_token");if(stored)return stored}catch(error){console.warn("[TokenResolver] Failed to read from sessionStorage:",error)}return null}determineSource(siteId,token){if(function hasDefaultToken(siteId){return isSiteConfigured(siteId)}(siteId)&amp;&amp;getDefaultToken(siteId)===token)return"default";return this.getGlobalToken()===token?"global":"site-specific"}invalidateCache(siteId){siteId?(this.cache.delete(siteId),console.debug(`[TokenResolver] Cache invalidated for ${siteId}`)):(this.cache.clear(),console.debug("[TokenResolver] All cache cleared"))}getCacheStats(){const entries=Array.from(this.cache.values()).map(entry=&gt;({siteId:entry.siteId,source:entry.source,age:Date.now()-entry.timestamp}));return{size:this.cache.size,entries:entries}}async resolveTokenWithMetadata(siteId){const startTime=performance.now(),cached=this.getCached(siteId);if(cached)return{token:cached.token,source:cached.source,cached:!0,resolutionTime:performance.now()-startTime};const token=await this.resolveToken(siteId);return{token:token,source:token?this.determineSource(siteId,token):null,cached:!1,resolutionTime:performance.now()-startTime}}on(event,callback){this.eventListeners.has(event)||this.eventListeners.set(event,new Set),this.eventListeners.get(event).add(callback)}off(event,callback){const listeners=this.eventListeners.get(event);listeners&amp;&amp;listeners.delete(callback)}emit(event,data){const listeners=this.eventListeners.get(event);listeners&amp;&amp;listeners.forEach(callback=&gt;{try{callback(data)}catch(error){console.error(`[TokenResolver] Error in event listener for ${event}:`,error)}}),window.dispatchEvent(new CustomEvent(`token:${event}`,{detail:data}))}async preloadTokens(siteIds){console.debug(`[TokenResolver] Preloading tokens for ${siteIds.length} sites`),await Promise.all(siteIds.map(siteId=&gt;this.resolveToken(siteId)))}}let tokenResolverInstance=null;async function getAceToken(siteId){return function getTokenResolver(){return tokenResolverInstance||(tokenResolverInstance=new TokenResolver),tokenResolverInstance}().resolveToken("ses_falls_city")}function initializeTokenInterceptor(axiosInstance){axiosInstance.interceptors.request.use(async config=&gt;{try{const token=await getAceToken();token?config.headers.Authorization=`Bearer ${token}`:console.warn("[tokenInterceptor] No ACE token available for request"),config.headers.Accept="application/x-msgpack, application/json",config.responseType&amp;&amp;"json"!==config.responseType||(config.responseType="arraybuffer")}catch(error){console.error("[tokenInterceptor] Error retrieving token:",error)}return config},error=&gt;(console.error("[tokenInterceptor] Request interceptor error:",error),Promise.reject(error))),axiosInstance.interceptors.response.use(response=&gt;{try{const contentType=response.headers["content-type"]||"";if(contentType.includes("msgpack")&amp;&amp;response.data instanceof ArrayBuffer){response.data=decode(new Uint8Array(response.data));const compressionRatio=response.headers["x-compression-ratio"];compressionRatio&amp;&amp;console.log(`[tokenInterceptor] MessagePack compression ratio: ${compressionRatio}`)}else if(response.data instanceof ArrayBuffer&amp;&amp;contentType.includes("json")){const text=(new TextDecoder).decode(response.data);response.data=JSON.parse(text)}}catch(decodeError){console.error("[tokenInterceptor] MessagePack decode error, attempting JSON fallback:",decodeError);try{if(response.data instanceof ArrayBuffer){const text=(new TextDecoder).decode(response.data);response.data=JSON.parse(text)}}catch(jsonError){console.error("[tokenInterceptor] JSON fallback failed:",jsonError)}}return response},async error=&gt;{var _a;const originalRequest=error.config;if(401===(null==(_a=error.response)?void 0:_a.status)&amp;&amp;!originalRequest._retry){originalRequest._retry=!0,console.warn("[tokenInterceptor] 401 Unauthorized - Token may be expired");try{const token=await getAceToken();if(token)return originalRequest.headers.Authorization=`Bearer ${token}`,axiosInstance(originalRequest)}catch(refreshError){console.error("[tokenInterceptor] Token refresh failed:",refreshError)}}return Promise.reject(error)})}const getActiveDashboardId=userId=&gt;{if(!userId)return"default";try{return localStorage.getItem(`building-vitals-active-dashboard-${userId}`)||"default"}catch(_error){}},setActiveDashboardId=(userId,dashboardId)=&gt;{if(userId)try{localStorage.setItem(`building-vitals-active-dashboard-${userId}`,dashboardId)}catch(_error){}},cleanForFirestore=obj=&gt;{if(void 0===obj)return null;if(null===obj||"object"!=typeof obj)return obj;if(Array.isArray(obj))return obj.map(item=&gt;cleanForFirestore(item));const cleaned={};for(const[key,value]of Object.entries(obj)){const cleanedValue=cleanForFirestore(value);void 0!==cleanedValue&amp;&amp;void 0!==value&amp;&amp;(cleaned[key]=cleanedValue)}for(const key in cleaned)cleaned[key];return cleaned},saveDashboardToFirestore=async(userId,dashboardId,config)=&gt;{try{if(!db)return!1;const configDocRef=doc(db,"dashboardConfigs",userId),dashboardDocRef=doc(configDocRef,"dashboards",dashboardId),cleanedLayouts=(layouts=&gt;{const cleanedLayouts={};return Object.entries(layouts).forEach(([breakpoint,layoutArray])=&gt;{Array.isArray(layoutArray)?cleanedLayouts[breakpoint]=layoutArray.map(layout=&gt;({i:layout.i,x:"number"==typeof layout.x?layout.x:0,y:"number"==typeof layout.y?layout.y:0,w:"number"==typeof layout.w?layout.w:6,h:"number"==typeof layout.h?layout.h:8,...layout.minW&amp;&amp;{minW:layout.minW},...layout.maxW&amp;&amp;{maxW:layout.maxW},...layout.minH&amp;&amp;{minH:layout.minH},...layout.maxH&amp;&amp;{maxH:layout.maxH},...layout.moved&amp;&amp;{moved:layout.moved},...layout.static&amp;&amp;{static:layout.static}})):cleanedLayouts[breakpoint]=[]}),cleanedLayouts})(config.layouts||{}),cleanedWidgets=(widgets=config.widgets||[],layouts=config.layouts||{},widgets.map(w=&gt;{var _a;const breakpointToUse=layouts.lg?"lg":Object.keys(layouts)[0];let currentLayoutItem=w.gridPos;if(breakpointToUse){const layoutItem=null==(_a=layouts[breakpointToUse])?void 0:_a.find(l=&gt;l.i===w.id);layoutItem&amp;&amp;(currentLayoutItem=layoutItem)}const gridPosToSave=currentLayoutItem?{i:w.id||"",x:"number"==typeof currentLayoutItem.x?currentLayoutItem.x:0,y:"number"==typeof currentLayoutItem.y?currentLayoutItem.y:0,w:"number"==typeof currentLayoutItem.w?currentLayoutItem.w:6,h:"number"==typeof currentLayoutItem.h?currentLayoutItem.h:8}:null;return cleanForFirestore({id:w.id,gridPos:gridPosToSave,selectedChartType:w.selectedChartType||"TimeSeries",selectedSite:w.selectedSite||"",timeRange:w.timeRange||"24h",constantValueInput:w.constantValueInput||"",scatterXAxisPointId:w.scatterXAxisPointId,scatterYAxisPointId:w.scatterYAxisPointId,scatterZAxisPointId:w.scatterZAxisPointId,streamScatterXAxisPointIds:w.streamScatterXAxisPointIds||[],streamScatterYAxisPointIds:w.streamScatterYAxisPointIds||[],customStartDate:w.customStartDate||null,customEndDate:w.customEndDate||null,name:w.name||(w.id&amp;&amp;"string"==typeof w.id&amp;&amp;w.id.includes("-")?`Chart ${parseInt(w.id.split("-")[1]||"0")+1}`:"New Chart"),displayMode:w.displayMode||"pointName",hiddenPoints:w.hiddenPoints||[],autoRefreshEnabled:w.autoRefreshEnabled||!1,autoRefreshInterval:w.autoRefreshInterval||60,gradientTheme:w.gradientTheme||"default",complianceThreshold:w.complianceThreshold,compliancePeriod:w.compliancePeriod,complianceMetric:w.complianceMetric||"Average",minValueInput:w.minValueInput,maxValueInput:w.maxValueInput,setpointValueInput:w.setpointValueInput,upperLimit:w.upperLimit,lowerLimit:w.lowerLimit,targetValue:w.targetValue,warningThreshold:w.warningThreshold,showBackgroundZones:w.showBackgroundZones,showAlerts:w.showAlerts,selectedPoints:(w.selectedPoints||[]).map(sp=&gt;({id:sp.id||"",name:sp.name||"",displayName:sp.displayName||sp.name||"",unit:sp.unit||"",color:sp.color||"hsl(0, 70%, 50%)",marker_tags:sp.marker_tags||[]}))})})),now=(new Date).toISOString(),dataToSave={dashboardId:dashboardId,name:config.name||"Main Dashboard",ownerId:userId,layouts:cleanedLayouts,widgets:cleanedWidgets,...config.timeRange&amp;&amp;{timeRange:config.timeRange},...config.customStartDate&amp;&amp;{customStartDate:config.customStartDate},...config.customEndDate&amp;&amp;{customEndDate:config.customEndDate},permissions:config.permissions||{},lastModified:now};return await setDoc(dashboardDocRef,dataToSave,{merge:!0}),await setDoc(configDocRef,{activeDashboardId:dashboardId,lastUpdated:now},{merge:!0}),!0}catch(_error){return!1}var widgets,layouts},getUserDashboardsFromFirestore=async userId=&gt;{try{if(!db)return[];const configDocRef=doc(db,"dashboardConfigs",userId),dashboardsCollectionRef=collection(configDocRef,"dashboards"),dashboardsSnapshot=await getDocs(dashboardsCollectionRef),dashboards=[];return dashboardsSnapshot.forEach(doc2=&gt;{const data=doc2.data();dashboards.push({id:doc2.id,name:data.name||"Main Dashboard",createdAt:data.createdAt||data.lastModified||(new Date).toISOString(),lastModified:data.lastModified||(new Date).toISOString(),sharedBy:data.sharedBy||userId})}),dashboards.sort((a,b)=&gt;new Date(b.lastModified).getTime()-new Date(a.lastModified).getTime())}catch(_error){return[]}},saveDashboardConfiguration=async(userId,dashboardId,layouts,widgets,dashboardName,timeRangeInput,customStartDate,customEndDate)=&gt;{let apiTimeRangeForStorage;if(timeRangeInput)if("string"==typeof timeRangeInput){apiTimeRangeForStorage=["24h","3d","7d","30d","90d","180d","365d","custom"].includes(timeRangeInput)?timeRangeInput:"custom"}else if("startTime"in timeRangeInput)apiTimeRangeForStorage=timeRangeInput;else if("start"in timeRangeInput){const rangeObj=timeRangeInput;apiTimeRangeForStorage={startTime:new Date(rangeObj.start).toISOString(),endTime:new Date(rangeObj.end).toISOString()}}if(((userId,dashboardId,layouts,widgets,dashboardName,timeRangeParam,customStartDate,customEndDate)=&gt;{try{let timeRangeToStore;timeRangeParam&amp;&amp;("string"==typeof timeRangeParam?timeRangeToStore=timeRangeParam:"object"==typeof timeRangeParam&amp;&amp;"startTime"in timeRangeParam&amp;&amp;"endTime"in timeRangeParam&amp;&amp;(timeRangeToStore="custom",customStartDate||(customStartDate=new Date(timeRangeParam.startTime).toISOString()),customEndDate||(customEndDate=new Date(timeRangeParam.endTime).toISOString())));const dashboardKey2=`building-vitals-dashboard-${userId||"anonymous"}-${dashboardId}`;let existingName="Main Dashboard";try{const existingData=localStorage.getItem(dashboardKey2);existingData&amp;&amp;(existingName=JSON.parse(existingData).name||"Main Dashboard")}catch(_e){}const finalName=dashboardName||existingName,dashboardData={id:dashboardId,name:finalName,layouts:layouts,widgets:widgets,timeRange:timeRangeToStore,customStartDate:customStartDate,customEndDate:customEndDate,lastModified:(new Date).toISOString()};localStorage.setItem(dashboardKey2,JSON.stringify(dashboardData));const dashboardsListKey=`building-vitals-dashboards-list-${userId||"anonymous"}`;let dashboardsList=[];try{const storedList=localStorage.getItem(dashboardsListKey);storedList&amp;&amp;(dashboardsList=JSON.parse(storedList))}catch(_e){}const existingIndex=dashboardsList.findIndex(d=&gt;d.id===dashboardId),dashboardMeta={id:dashboardId,name:finalName,lastModified:(new Date).toISOString(),createdAt:existingIndex&gt;=0?dashboardsList[existingIndex].createdAt:(new Date).toISOString()};existingIndex&gt;=0?dashboardsList[existingIndex]=dashboardMeta:dashboardsList.push(dashboardMeta),localStorage.setItem(dashboardsListKey,JSON.stringify(dashboardsList)),setActiveDashboardId(userId,dashboardId)}catch(_error){}})(userId,dashboardId,layouts,widgets,dashboardName,apiTimeRangeForStorage,customStartDate,customEndDate),userId){let firestoreTimeRange;timeRangeInput&amp;&amp;("string"==typeof timeRangeInput?firestoreTimeRange=timeRangeInput:("startTime"in timeRangeInput||"start"in timeRangeInput)&amp;&amp;(firestoreTimeRange="custom"));const configForFirestore={layouts:layouts,widgets:widgets,name:dashboardName,timeRange:firestoreTimeRange,customStartDate:customStartDate,customEndDate:customEndDate};await saveDashboardToFirestore(userId,dashboardId,configForFirestore)}},loadDashboardConfiguration=async(userId,dashboardId)=&gt;{const activeDashboardId=dashboardId||getActiveDashboardId(userId);let result=null;if(userId&amp;&amp;(result=await(async(userId,dashboardId)=&gt;{try{if(!db)return null;const configDocRef=doc(db,"dashboardConfigs",userId),dashboardDocRef=doc(configDocRef,"dashboards",dashboardId),dashboardDocSnap=await getDoc(dashboardDocRef);if(dashboardDocSnap.exists()){const dashboardData=dashboardDocSnap.data();let processedLayouts={};dashboardData.layouts&amp;&amp;"object"==typeof dashboardData.layouts&amp;&amp;(processedLayouts=dashboardData.layouts);let processedWidgets=[];return Array.isArray(dashboardData.widgets)&amp;&amp;(processedWidgets=dashboardData.widgets.map(w=&gt;{var _a;if(w.gridPos&amp;&amp;"object"==typeof w.gridPos)w.gridPos.x="number"==typeof w.gridPos.x?w.gridPos.x:0,w.gridPos.y="number"==typeof w.gridPos.y?w.gridPos.y:0,w.gridPos.w="number"==typeof w.gridPos.w?w.gridPos.w:6,w.gridPos.h="number"==typeof w.gridPos.h?w.gridPos.h:8;else{const breakpointToUse=processedLayouts.lg?"lg":Object.keys(processedLayouts)[0],widgetIdString=w.id||`temp-id-${Math.random().toString(36).substr(2,9)}`,layoutItem=breakpointToUse&amp;&amp;w.id?null==(_a=processedLayouts[breakpointToUse])?void 0:_a.find(l=&gt;l.i===w.id):null;w.gridPos=layoutItem||{i:widgetIdString,x:0,y:0,w:6,h:8},w.id||(w.id=widgetIdString)}return{...w,customStartDate:w.customStartDate||null,customEndDate:w.customEndDate||null,name:w.name||(w.id&amp;&amp;"string"==typeof w.id&amp;&amp;w.id.includes("-")?`Chart ${parseInt(w.id.split("-")[1]||"0")+1}`:w.name||"New Chart"),displayMode:w.displayMode||"pointName",hiddenPoints:Array.isArray(w.hiddenPoints)?w.hiddenPoints:[],selectedPoints:Array.isArray(w.selectedPoints)?w.selectedPoints:[],selectedChartType:w.selectedChartType||"TimeSeries",selectedSite:w.selectedSite||"",timeRange:w.timeRange||"24h",scatterXAxisPointId:w.scatterXAxisPointId||null,scatterYAxisPointId:w.scatterYAxisPointId||null,scatterZAxisPointId:w.scatterZAxisPointId||null,streamScatterXAxisPointIds:Array.isArray(w.streamScatterXAxisPointIds)?w.streamScatterXAxisPointIds:[],streamScatterYAxisPointIds:Array.isArray(w.streamScatterYAxisPointIds)?w.streamScatterYAxisPointIds:[],autoRefreshEnabled:w.autoRefreshEnabled||!1,autoRefreshInterval:w.autoRefreshInterval||60,gradientTheme:w.gradientTheme||"default",complianceType:w.complianceType||"Between Min/Max",complianceSetpoint:w.complianceSetpoint,complianceMin:w.complianceMin,complianceMax:w.complianceMax,minValueInput:w.minValueInput||"",maxValueInput:w.maxValueInput||"",setpointValueInput:w.setpointValueInput||"",constantValueInput:w.constantValueInput||""}})),{...dashboardData,dashboardId:dashboardId,layouts:processedLayouts,widgets:processedWidgets,name:dashboardData.name||"Main Dashboard",permissions:dashboardData.permissions||{},timeRange:dashboardData.timeRange||"24h",customStartDate:dashboardData.customStartDate||null,customEndDate:dashboardData.customEndDate||null}}return null}catch(_error){return null}})(userId,activeDashboardId)),result||(result=((userId,dashboardId)=&gt;{try{const dashboardJson=localStorage.getItem(dashboardKey),dashboardData=JSON.parse(dashboardJson);return setActiveDashboardId(userId,dashboardId),{dashboardId:dashboardId,name:dashboardData.name||"Main Dashboard",layouts:dashboardData.layouts||{},widgets:dashboardData.widgets||[],ownerId:userId||"anonymous",permissions:dashboardData.permissions||{},createdAt:dashboardData.createdAt||new Date(0).toISOString(),lastModified:dashboardData.lastModified||(new Date).toISOString(),timeRange:dashboardData.timeRange,customStartDate:dashboardData.customStartDate,customEndDate:dashboardData.customEndDate}}catch(_error){}})(userId,activeDashboardId)),!result){const owner=userId||"anonymous",now=(new Date).toISOString();result={dashboardId:activeDashboardId,layouts:{},widgets:[],name:"Main Dashboard",ownerId:owner,permissions:{},timeRange:"24h",createdAt:now,lastModified:now},await saveDashboardConfiguration(userId,activeDashboardId,result.layouts,result.widgets,result.name)}return result?{layouts:result.layouts||{},widgets:result.widgets||[],name:result.name||"Main Dashboard",dashboardId:activeDashboardId,timeRange:result.timeRange,customStartDate:result.customStartDate||null,customEndDate:result.customEndDate||null}:null};const snapshotService=new class SnapshotService{constructor(){__publicField(this,"COLLECTION_NAME","snapshots")}async getUserSnapshots(userId){try{const q=query(collection(db,this.COLLECTION_NAME),where("userId","==",userId),orderBy("createdAt","desc"));return(await getDocs(q)).docs.map(doc2=&gt;({id:doc2.id,...doc2.data()}))}catch(error){return console.error("Error fetching snapshots:",error),[]}}async createSnapshot(userId,snapshot){try{await addDoc(collection(db,this.COLLECTION_NAME),{...snapshot,userId:userId,createdAt:serverTimestamp(),updatedAt:serverTimestamp()})}catch(error){throw console.error("Error creating snapshot:",error),error}}async deleteSnapshot(snapshotId,_chartImage){try{await deleteDoc(doc(db,this.COLLECTION_NAME,snapshotId))}catch(error){throw console.error("Error deleting snapshot:",error),error}}exportSnapshot(snapshot){try{const dataStr=JSON.stringify(snapshot,null,2),dataUri="data:application/json;charset=utf-8,"+encodeURIComponent(dataStr),exportFileDefaultName=`dashboard-snapshot-${snapshot.name.toLowerCase().replace(/\s+/g,"-")}.json`,linkElement=document.createElement("a");linkElement.setAttribute("href",dataUri),linkElement.setAttribute("download",exportFileDefaultName),linkElement.click()}catch(error){throw console.error("Error exporting snapshot:",error),error}}};async function fetchTimeseriesForPoints(siteName,selectedPoints,startTime,endTime,token,onProgress,useBinary=!1){console.log("[Query Worker] Starting SINGLE-REQUEST fetch:",{siteName:siteName,pointCount:selectedPoints.length,startTime:startTime,endTime:endTime,performance:"OPTIMIZED (D1/R2 unified access)"});const pointNames=selectedPoints.map(p=&gt;p.original_name||p.name).filter(Boolean);if(0===pointNames.length)return console.warn("[Query Worker] No valid point names provided"),{};const startTimeMs=new Date(startTime).getTime(),endTimeMs=new Date(endTime).getTime(),queryUrl=new URL("/timeseries/query",API_ENDPOINTS.QUERY_WORKER_URL);queryUrl.searchParams.set("site_name",siteName),queryUrl.searchParams.set("point_names",pointNames.join(",")),queryUrl.searchParams.set("start_time",String(startTimeMs)),queryUrl.searchParams.set("end_time",String(endTimeMs)),console.log("[Query Worker] Fetching from unified D1/R2 endpoint:",{url:queryUrl.toString(),pointNames:pointNames.map(n=&gt;n.split("/").slice(-2).join("/")),dateRange:{start:new Date(startTimeMs).toISOString(),end:new Date(endTimeMs).toISOString(),spanDays:((endTimeMs-startTimeMs)/864e5).toFixed(1)}});const fetchStartTime=Date.now();try{const response=await fetch(queryUrl.toString(),{headers:{"X-ACE-Token":token,Accept:"application/json"}});if(!response.ok){const errorText=await response.text();throw console.error("[Query Worker] Request failed:",{status:response.status,statusText:response.statusText,error:errorText}),new Error(`Query Worker failed: ${response.status} ${response.statusText}`)}const data=await response.json(),fetchDuration=Date.now()-fetchStartTime;console.log("[Query Worker] Response received:",{source:data.metadata.source,sampleCount:data.metadata.sample_count,queryTimeMs:data.metadata.query_time_ms,totalFetchMs:fetchDuration,pointsReturned:data.point_names.length});const grouped={};return pointNames.forEach(pointName=&gt;{grouped[pointName]=[]}),data.samples.forEach(sample=&gt;{grouped[sample.point_name]||(grouped[sample.point_name]=[]),grouped[sample.point_name].push({timestamp:sample.timestamp,value:sample.value})}),Object.keys(grouped).forEach(pointName=&gt;{grouped[pointName].sort((a,b)=&gt;a.timestamp-b.timestamp)}),console.log("[Query Worker] Grouping complete:",{pointsWithData:Object.keys(grouped).filter(k=&gt;grouped[k].length&gt;0).length,samplesPerPoint:Object.entries(grouped).map(([name,data2])=&gt;({name:name.split("/").pop(),count:data2.length})),totalSamples:data.metadata.sample_count,performance:`${fetchDuration}ms total (${data.metadata.query_time_ms}ms query)`}),onProgress&amp;&amp;onProgress(data.metadata.sample_count,!1),grouped}catch(error){throw console.error("[Query Worker] Fetch failed:",error),error}}const pointService=new class PointService{constructor(){__publicField(this,"allPoints",[]),__publicField(this,"pointsById",new Map),__publicField(this,"pointsByTag",new Map),__publicField(this,"pointsByDevice",new Map),__publicField(this,"uniqueTags",new Set),__publicField(this,"loading",!1),__publicField(this,"loaded",!1),__publicField(this,"loadProgress",{current:0,total:0}),__publicField(this,"subscribers",new Set),__publicField(this,"cachedSiteName",null)}subscribe(callback){return this.subscribers.add(callback),()=&gt;this.subscribers.delete(callback)}notifyProgress(){this.subscribers.forEach(callback=&gt;callback(this.loadProgress))}async loadAllPoints(siteName,options={}){if(this.loaded&amp;&amp;this.cachedSiteName===siteName)return this.allPoints;if(this.cachedSiteName!==siteName&amp;&amp;(this.reset(),this.cachedSiteName=siteName),this.loading)return new Promise(resolve=&gt;{const checkInterval=setInterval(()=&gt;{this.loading||(clearInterval(checkInterval),resolve(this.allPoints))},100)});this.loading=!0,this.loadProgress={current:0,total:0};const{batchSize:batchSize=5,perPage:perPage=100}=options;try{const{all:pythonPoints}=await cachedSitePointService.fetchPointsForSite(siteName),allPoints=pythonPoints.map(point=&gt;({...point,id:point.id||point.name,name:point.name,collect_enabled:point.collect_enabled??!0,collect_interval:point.collect_interval??60,marker_tags:point.marker_tags||[],bacnet_data:point.bacnet_data}));return this.loadProgress.total=allPoints.length,this.loadProgress.current=allPoints.length,this.notifyProgress(),this.processPoints(allPoints),this.loaded=!0,this.allPoints}catch(error){throw error}finally{this.loading=!1}}processPoints(points){this.allPoints=points,this.pointsById.clear(),this.pointsByTag.clear(),this.pointsByDevice.clear(),this.uniqueTags.clear(),points.forEach(point=&gt;{var _a;if(this.pointsById.set(point.id,point),point.marker_tags&amp;&amp;Array.isArray(point.marker_tags)&amp;&amp;point.marker_tags.forEach(tag=&gt;{this.uniqueTags.add(tag),this.pointsByTag.has(tag)||this.pointsByTag.set(tag,[]),this.pointsByTag.get(tag).push(point)}),null==(_a=point.bacnet_data)?void 0:_a.device_name){const deviceName=point.bacnet_data.device_name;this.pointsByDevice.has(deviceName)||this.pointsByDevice.set(deviceName,[]),this.pointsByDevice.get(deviceName).push(point)}})}filterPoints(criteria={}){let filtered=[...this.allPoints];if(!1!==criteria.collectEnabled&amp;&amp;(filtered=filtered.filter(point=&gt;!0===point.collect_enabled)),criteria.tags&amp;&amp;criteria.tags.length&gt;0){const tagSet=new Set(criteria.tags);filtered=filtered.filter(point=&gt;{var _a;return null==(_a=point.marker_tags)?void 0:_a.some(tag=&gt;tagSet.has(tag))})}if(criteria.devices&amp;&amp;criteria.devices.length&gt;0){const deviceSet=new Set(criteria.devices);filtered=filtered.filter(point=&gt;{var _a;return(null==(_a=point.bacnet_data)?void 0:_a.device_name)&amp;&amp;deviceSet.has(point.bacnet_data.device_name)})}if(criteria.searchText){const search=criteria.searchText.toLowerCase();filtered=filtered.filter(point=&gt;{var _a,_b,_c,_d,_e;return(null==(_a=point.name)?void 0:_a.toLowerCase().includes(search))||(null==(_c=null==(_b=point.bacnet_data)?void 0:_b.object_name)?void 0:_c.toLowerCase().includes(search))||(null==(_e=null==(_d=point.bacnet_data)?void 0:_d.device_name)?void 0:_e.toLowerCase().includes(search))})}if(criteria.units&amp;&amp;criteria.units.length&gt;0){const unitsSet=new Set(criteria.units);filtered=filtered.filter(point=&gt;{var _a;return(null==(_a=point.bacnet_data)?void 0:_a.object_units)&amp;&amp;unitsSet.has(point.bacnet_data.object_units)})}return filtered}getPointsByIds(ids){return ids.map(id=&gt;this.pointsById.get(id)).filter(point=&gt;void 0!==point)}getAllTags(){return Array.from(this.uniqueTags).sort()}getAllDevices(){return Array.from(this.pointsByDevice.keys()).sort()}getAllUnits(){const units=new Set;return this.allPoints.forEach(point=&gt;{var _a;(null==(_a=point.bacnet_data)?void 0:_a.object_units)&amp;&amp;units.add(point.bacnet_data.object_units)}),Array.from(units).sort()}isLoading(){return this.loading}isLoaded(){return this.loaded}reset(){this.allPoints=[],this.pointsById.clear(),this.pointsByTag.clear(),this.pointsByDevice.clear(),this.uniqueTags.clear(),this.loaded=!1,this.loading=!1,this.loadProgress={current:0,total:0},this.cachedSiteName=null}};const debugService=new class DebugService{constructor(){__publicField(this,"logs",[]),__publicField(this,"apiRequests",[]),__publicField(this,"performanceMetrics",[]),__publicField(this,"maxLogSize",1e3),__publicField(this,"maxApiRequestSize",500),__publicField(this,"listeners",new Set),__publicField(this,"isEnabled",!0)}overrideConsoleMethods(){const originalLog=console.log,originalWarn=console.warn,originalError=console.error;console.log=(...args)=&gt;{originalLog(...args),this.log("info","console",this.formatConsoleArgs(args))},console.warn=(...args)=&gt;{originalWarn(...args),this.log("warn","console",this.formatConsoleArgs(args))},console.error=(...args)=&gt;{var _a;originalError(...args),this.log("error","console",this.formatConsoleArgs(args),null==(_a=args[0])?void 0:_a.stack)}}formatConsoleArgs(args){return args.map(arg=&gt;{if("object"==typeof arg)try{return JSON.stringify(arg,null,2)}catch{return String(arg)}return String(arg)}).join(" ")}log(level,category,message,data,stack){if(!this.isEnabled)return;const entry={id:`log-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,timestamp:new Date,level:level,category:category,message:message,data:data,stack:stack};this.logs.push(entry),this.logs.length&gt;this.maxLogSize&amp;&amp;(this.logs=this.logs.slice(-this.maxLogSize)),this.notifyListeners("log",entry)}debug(category,message,data){this.log("debug",category,message,data)}info(category,message,data){this.log("info",category,message,data)}warn(category,message,data){this.log("warn",category,message,data)}error(category,message,error,data){this.log("error",category,message,{error:null==error?void 0:error.message,...data},null==error?void 0:error.stack)}logApiRequest(request){if(!this.isEnabled)return;const log={id:`api-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,timestamp:new Date,method:request.method||"GET",url:request.url||"",endpoint:this.extractEndpoint(request.url||""),...request};this.apiRequests.push(log),this.apiRequests.length&gt;this.maxApiRequestSize&amp;&amp;(this.apiRequests=this.apiRequests.slice(-this.maxApiRequestSize)),this.notifyListeners("api",log)}updateApiRequest(id,update){const index=this.apiRequests.findIndex(req=&gt;req.id===id);-1!==index&amp;&amp;(this.apiRequests[index]={...this.apiRequests[index],...update},this.notifyListeners("api",this.apiRequests[index]))}logPerformance(category,metric,value,unit="ms",metadata){if(!this.isEnabled)return;const entry={id:`perf-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,timestamp:new Date,category:category,metric:metric,value:value,unit:unit,metadata:metadata};this.performanceMetrics.push(entry),this.notifyListeners("performance",entry)}logDataValidation(category,message,invalidData,validationErrors){this.warn(category,`Data validation failed: ${message}`,{invalidData:invalidData,validationErrors:validationErrors,sampleData:this.getSampleData(invalidData)})}getSampleData(data,maxItems=5){return Array.isArray(data)?data.slice(0,maxItems):data}extractEndpoint(url){try{return new URL(url,window.location.origin).pathname}catch{return url}}addListener(listener){this.listeners.add(listener)}removeListener(listener){this.listeners.delete(listener)}notifyListeners(type,data){this.listeners.forEach(listener=&gt;{try{listener(type,data)}catch(error){console.error("[DebugService] Debug listener error:",error)}})}getLogs(filter){return filter?this.logs.filter(log=&gt;(!filter.level||log.level===filter.level)&amp;&amp;!(filter.category&amp;&amp;!log.category.includes(filter.category))):[...this.logs]}getApiRequests(filter){return filter?this.apiRequests.filter(req=&gt;(!filter.status||req.status===filter.status)&amp;&amp;!(filter.endpoint&amp;&amp;!req.endpoint.includes(filter.endpoint))):[...this.apiRequests]}getPerformanceMetrics(category){return category?this.performanceMetrics.filter(m=&gt;m.category===category):[...this.performanceMetrics]}exportLogs(){const data={exportTime:(new Date).toISOString(),logs:this.logs,apiRequests:this.apiRequests,performanceMetrics:this.performanceMetrics,appInfo:{userAgent:navigator.userAgent,url:window.location.href,timestamp:(new Date).toISOString()}};return JSON.stringify(data,null,2)}exportAsMarkdown(){let markdown="# Building Vitals Debug Report\n\n";return markdown+=`**Generated:** ${(new Date).toLocaleString()}\n`,markdown+=`**URL:** ${window.location.href}\n\n`,markdown+="## Application Logs\n\n",this.logs.forEach(log=&gt;{const icon="error"===log.level?"❌":"warn"===log.level?"⚠️":"ℹ️";markdown+=`${icon} **[${log.timestamp.toLocaleTimeString()}]** [${log.category}] ${log.message}\n`,log.data&amp;&amp;(markdown+=`\`\`\`json\n${JSON.stringify(log.data,null,2)}\n\`\`\`\n`),markdown+="\n"}),markdown+="## API Requests\n\n",this.apiRequests.forEach(req=&gt;{const statusIcon=req.status&amp;&amp;req.status&gt;=400?"❌":"✅";markdown+=`${statusIcon} **${req.method} ${req.endpoint}** - Status: ${req.status||"pending"} (${req.responseTime||"?"}ms)\n`,req.payload&amp;&amp;(markdown+=`Request:\n\`\`\`json\n${JSON.stringify(req.payload,null,2)}\n\`\`\`\n`),req.error&amp;&amp;(markdown+=`Error: ${req.error}\n`),markdown+="\n"}),markdown}clearLogs(){this.logs=[],this.notifyListeners("clear","logs")}clearApiRequests(){this.apiRequests=[],this.notifyListeners("clear","api")}clearAll(){this.logs=[],this.apiRequests=[],this.performanceMetrics=[],this.notifyListeners("clear","all")}setEnabled(enabled){this.isEnabled=enabled}};function timeRangeToSeconds(range){switch(range){case"1h":return 3600;case"24h":default:return 86400;case"7d":return 604800;case"30d":return 2592e3}}async function fetchMetrics(timeRange="24h"){try{const since=Math.floor(Date.now()/1e3)-timeRangeToSeconds(timeRange),response=await fetch("https://api.cloudflare.com/client/v4/accounts/undefined/analytics_engine/sql",{method:"POST",headers:{Authorization:"Bearer undefined","Content-Type":"application/json"},body:JSON.stringify({query:`\n            SELECT\n              COUNT(*) as requestCount,\n              AVG(latency) as avgLatency,\n              QUANTILE(latency, 0.5) as p50Latency,\n              QUANTILE(latency, 0.95) as p95Latency,\n              QUANTILE(latency, 0.99) as p99Latency,\n              SUM(CASE WHEN cacheStatus = 'HIT' THEN 1 ELSE 0 END) as cacheHits,\n              SUM(CASE WHEN cacheStatus = 'MISS' THEN 1 ELSE 0 END) as cacheMisses,\n              SUM(CASE WHEN status &gt;= 400 THEN 1 ELSE 0 END) as errorCount\n            FROM ace_worker_analytics\n            WHERE timestamp &gt;= ${since}\n          `})});if(!response.ok)throw new Error(`Analytics API error: ${response.statusText}`);const row=(await response.json()).data[0],totalRequests=row.requestCount||0,cacheHits=row.cacheHits||0,cacheMisses=row.cacheMisses||0,errorCount=row.errorCount||0;return{requestCount:totalRequests,avgLatency:row.avgLatency||0,p50Latency:row.p50Latency||0,p95Latency:row.p95Latency||0,p99Latency:row.p99Latency||0,cacheHitRate:totalRequests&gt;0?cacheHits/totalRequests:0,cacheHits:cacheHits,cacheMisses:cacheMisses,errorRate:totalRequests&gt;0?errorCount/totalRequests:0,errorCount:errorCount,apiCallReduction:totalRequests&gt;0?cacheHits/totalRequests:0,bandwidthSaved:2.5*cacheHits/1024,timeRange:timeRange,lastUpdated:new Date}}catch(error){return console.error("Failed to fetch metrics:",error),function generateMockMetrics(timeRange){const now=Date.now(),baseRequests="1h"===timeRange?1200:"24h"===timeRange?28800:2e5;return{requestCount:baseRequests+Math.floor(1e3*Math.random()),avgLatency:45+20*Math.random(),p50Latency:35+10*Math.random(),p95Latency:120+30*Math.random(),p99Latency:280+50*Math.random(),cacheHitRate:.85+.1*Math.random(),cacheHits:Math.floor(.87*baseRequests),cacheMisses:Math.floor(.13*baseRequests),errorRate:.001+.004*Math.random(),errorCount:Math.floor(.002*baseRequests),apiCallReduction:.92+.05*Math.random(),bandwidthSaved:1250+500*Math.random(),timeRange:timeRange,lastUpdated:new Date(now)}}(timeRange)}}async function fetchHistoricalMetrics(timeRange="24h"){try{const since=Math.floor(Date.now()/1e3)-timeRangeToSeconds(timeRange),buckets="1h"===timeRange?12:"24h"===timeRange?24:30,bucketSize=timeRangeToSeconds(timeRange)/buckets,response=await fetch("https://api.cloudflare.com/client/v4/accounts/undefined/analytics_engine/sql",{method:"POST",headers:{Authorization:"Bearer undefined","Content-Type":"application/json"},body:JSON.stringify({query:`\n            SELECT\n              intDiv(timestamp, ${bucketSize}) * ${bucketSize} as bucket,\n              QUANTILE(latency, 0.5) as p50,\n              QUANTILE(latency, 0.95) as p95,\n              QUANTILE(latency, 0.99) as p99,\n              AVG(CASE WHEN cacheStatus = 'HIT' THEN 1 ELSE 0 END) as hitRate,\n              AVG(CASE WHEN status &gt;= 400 THEN 1 ELSE 0 END) as errorRate,\n              COUNT(*) as requests\n            FROM ace_worker_analytics\n            WHERE timestamp &gt;= ${since}\n            GROUP BY bucket\n            ORDER BY bucket\n          `})});if(!response.ok)throw new Error(`Analytics API error: ${response.statusText}`);const data=await response.json();return{latency:{p50:data.data.map(row=&gt;({timestamp:1e3*row.bucket,value:row.p50})),p95:data.data.map(row=&gt;({timestamp:1e3*row.bucket,value:row.p95})),p99:data.data.map(row=&gt;({timestamp:1e3*row.bucket,value:row.p99}))},cacheHitRate:data.data.map(row=&gt;({timestamp:1e3*row.bucket,value:row.hitRate})),errorRate:data.data.map(row=&gt;({timestamp:1e3*row.bucket,value:row.errorRate})),requestVolume:data.data.map(row=&gt;({timestamp:1e3*row.bucket,value:row.requests}))}}catch(error){return console.error("Failed to fetch historical metrics:",error),function generateMockHistorical(timeRange){const points="1h"===timeRange?12:"24h"===timeRange?24:30,now=Date.now(),interval=1e3*timeRangeToSeconds(timeRange)/points,generateSeries=(base,variance)=&gt;Array.from({length:points},(_,i)=&gt;({timestamp:now-(points-i)*interval,value:base+Math.random()*variance-variance/2}));return{latency:{p50:generateSeries(35,10),p95:generateSeries(120,30),p99:generateSeries(280,50)},cacheHitRate:generateSeries(.87,.06),errorRate:generateSeries(.002,.003),requestVolume:generateSeries(1e3,300)}}(timeRange)}}async function fetchErrorLogs(timeRange="24h"){return function generateMockErrors(){const errorTypes=["TimeoutError","ValidationError","NetworkError","AuthError","CacheError"],endpoints=["/points","/timeseries","/sites","/devices"],now=Date.now();return Array.from({length:15},(_,i)=&gt;({id:`error-${i}`,timestamp:new Date(now-864e5*Math.random()),errorType:errorTypes[Math.floor(Math.random()*errorTypes.length)],errorMessage:"Sample error message for testing",endpoint:endpoints[Math.floor(Math.random()*endpoints.length)],statusCode:[400,404,500,503][Math.floor(4*Math.random())],stackTrace:"at Function.handler (worker.js:123:45)",metadata:{attemptNumber:Math.floor(3*Math.random())+1}}))}()}async function fetchCacheAnalytics(timeRange="24h"){return{totalRequests:125e3,hitRate:.87,missRate:.13,avgTTLUtilization:.78,optimalTTL:300,topEndpoints:[{endpoint:"/points",hitRate:.92,requests:45e3,avgLatency:32},{endpoint:"/timeseries",hitRate:.85,requests:38e3,avgLatency:45},{endpoint:"/sites",hitRate:.95,requests:25e3,avgLatency:18},{endpoint:"/devices",hitRate:.88,requests:17e3,avgLatency:28}],keyPatterns:[{pattern:"site:*:points",count:45e3,avgSize:2.5},{pattern:"timeseries:*",count:38e3,avgSize:12.8},{pattern:"site:*:devices",count:17e3,avgSize:3.2}]}}async function fetchSystemStatus(){return function generateMockStatus(){return{healthy:!0,workerStatus:"online",lastDataReceived:new Date,activeConnections:42+Math.floor(20*Math.random()),uptimePercentage:99.8+.2*Math.random()}}()}export{setUser as A,tokenExpirationMonitor as B,encryption as C,secureStorage$1 as D,aceTokenResolver as E,tokenMigration as F,pointPreloadService$1 as G,MultiTokenManager as M,TokenValidator as T,secureStorage as a,initializeTokenInterceptor as b,setActiveDashboardId as c,snapshotService as d,encryptionService as e,getActiveDashboardId as f,getAceApiToken$1 as g,saveDashboardConfiguration as h,initializeBatchApiService as i,getUserDashboardsFromFirestore as j,fetchTimeseriesForPoints as k,loadDashboardConfiguration as l,cachedSitePointService as m,pointPreloadService as n,debugService as o,pointService as p,fetchMetrics as q,fetchHistoricalMetrics as r,setAceApiToken as s,tokenMigrationService as t,fetchErrorLogs as u,validateAceToken as v,fetchCacheAnalytics as w,fetchSystemStatus as x,getSiteTimezoneWithFallback as y,errorTracker as z};</span>
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-10-16T12:41:31.984Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    