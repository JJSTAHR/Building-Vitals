<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tooltip Rendering Performance Tests</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }

        .test-container {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .test-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .test-description {
            color: #666;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .results {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }

        .metric {
            margin-bottom: 8px;
        }

        .metric-label {
            color: #666;
            display: inline-block;
            width: 200px;
        }

        .metric-value {
            color: #333;
            font-weight: bold;
        }

        .metric-value.good {
            color: #10b981;
        }

        .metric-value.warning {
            color: #f59e0b;
        }

        .metric-value.bad {
            color: #ef4444;
        }

        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }

        button:hover {
            background: #2563eb;
        }

        .test-points {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .point {
            width: 40px;
            height: 40px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            position: relative;
        }

        /* CSS Approach A: width: auto */
        .tooltip-auto {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            width: auto;
            max-width: min(500px, 90vw);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        /* CSS Approach B: width: fit-content */
        .tooltip-fit-content {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            width: fit-content;
            max-width: 500px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        /* CSS Approach C: min-content + max-width */
        .tooltip-min-content {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            width: min-content;
            max-width: 500px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        /* Optimized approach with GPU acceleration */
        .tooltip-optimized {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) translateZ(0);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            width: fit-content;
            max-width: 500px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            will-change: opacity;
            backface-visibility: hidden;
        }

        .tooltip-visible {
            opacity: 1;
        }

        .control-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 300px;
        }

        .control-panel h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .control-panel button {
            width: 100%;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <h1 style="margin-bottom: 20px;">Tooltip Rendering Performance Tests</h1>

    <div class="test-container">
        <div class="test-title">Test 1: CSS Approaches Comparison</div>
        <div class="test-description">
            Measures rendering performance of different CSS width approaches over 1000 iterations
        </div>
        <button onclick="runCSSApproachTest()">Run CSS Approach Test</button>
        <div id="css-results" class="results" style="display: none;"></div>
    </div>

    <div class="test-container">
        <div class="test-title">Test 2: Reflow/Repaint Analysis</div>
        <div class="test-description">
            Analyzes layout thrashing and reflow frequency for each approach
        </div>
        <button onclick="runReflowTest()">Run Reflow Test</button>
        <div id="reflow-results" class="results" style="display: none;"></div>
    </div>

    <div class="test-container">
        <div class="test-title">Test 3: GPU Acceleration Impact</div>
        <div class="test-description">
            Compares standard vs GPU-accelerated tooltip rendering
        </div>
        <button onclick="runGPUTest()">Run GPU Test</button>
        <div id="gpu-results" class="results" style="display: none;"></div>
    </div>

    <div class="test-container">
        <div class="test-title">Test 4: Text Measurement Performance</div>
        <div class="test-description">
            Compares Canvas API, DOM measurement, and cached approaches
        </div>
        <button onclick="runTextMeasurementTest()">Run Text Measurement Test</button>
        <div id="text-results" class="results" style="display: none;"></div>
    </div>

    <div class="test-container">
        <div class="test-title">Test 5: Mobile Simulation</div>
        <div class="test-description">
            Simulates touch events and mobile viewport constraints
        </div>
        <button onclick="runMobileTest()">Run Mobile Test</button>
        <div id="mobile-results" class="results" style="display: none;"></div>
    </div>

    <div class="test-container">
        <div class="test-title">Test 6: Memory Impact</div>
        <div class="test-description">
            Measures memory usage for different tooltip implementations
        </div>
        <button onclick="runMemoryTest()">Run Memory Test</button>
        <div id="memory-results" class="results" style="display: none;"></div>
    </div>

    <div class="test-container">
        <div class="test-title">Interactive Test Area</div>
        <div class="test-description">
            Hover over points to test different tooltip implementations
        </div>
        <div class="test-points" id="test-points"></div>
    </div>

    <div class="control-panel">
        <h3>Performance Monitor</h3>
        <div id="live-stats" style="font-size: 12px; color: #666;"></div>
    </div>

    <script>
        // Utility: Performance measurement
        function measurePerformance(fn, iterations = 1000) {
            const times = [];

            // Warm-up
            for (let i = 0; i < 10; i++) fn();

            // Measure
            for (let i = 0; i < iterations; i++) {
                const start = performance.now();
                fn();
                const end = performance.now();
                times.push(end - start);
            }

            const avg = times.reduce((a, b) => a + b) / times.length;
            const min = Math.min(...times);
            const max = Math.max(...times);
            const p95 = times.sort((a, b) => a - b)[Math.floor(times.length * 0.95)];

            return { avg, min, max, p95, times };
        }

        // Test 1: CSS Approaches
        function runCSSApproachTest() {
            const results = document.getElementById('css-results');
            results.style.display = 'block';
            results.textContent = 'Running tests...\n\n';

            setTimeout(() => {
                const container = document.createElement('div');
                container.style.position = 'relative';
                container.style.width = '100px';
                container.style.height = '100px';
                document.body.appendChild(container);

                const tests = [
                    { name: 'width: auto', className: 'tooltip-auto' },
                    { name: 'width: fit-content', className: 'tooltip-fit-content' },
                    { name: 'width: min-content', className: 'tooltip-min-content' },
                    { name: 'GPU-accelerated', className: 'tooltip-optimized' }
                ];

                const testResults = [];

                tests.forEach(test => {
                    const tooltip = document.createElement('div');
                    tooltip.className = test.className;
                    tooltip.textContent = 'Sample tooltip text';
                    container.appendChild(tooltip);

                    const result = measurePerformance(() => {
                        tooltip.classList.toggle('tooltip-visible');
                        const width = tooltip.offsetWidth; // Force reflow
                    }, 1000);

                    testResults.push({ ...test, ...result });
                    container.removeChild(tooltip);
                });

                document.body.removeChild(container);

                let output = 'CSS APPROACH PERFORMANCE (1000 iterations)\n\n';
                testResults.forEach((result, index) => {
                    const rating = result.avg < 0.5 ? 'good' : result.avg < 1.0 ? 'warning' : 'bad';
                    output += `${index + 1}. ${result.name}\n`;
                    output += `   Average: ${result.avg.toFixed(4)}ms (${rating})\n`;
                    output += `   Min: ${result.min.toFixed(4)}ms\n`;
                    output += `   Max: ${result.max.toFixed(4)}ms\n`;
                    output += `   P95: ${result.p95.toFixed(4)}ms\n\n`;
                });

                const fastest = testResults.reduce((a, b) => a.avg < b.avg ? a : b);
                output += `\nRECOMMENDATION: ${fastest.name} is fastest\n`;
                output += `Performance gain: ${((testResults[0].avg / fastest.avg - 1) * 100).toFixed(1)}% faster than baseline\n`;

                results.textContent = output;
            }, 100);
        }

        // Test 2: Reflow Analysis
        function runReflowTest() {
            const results = document.getElementById('reflow-results');
            results.style.display = 'block';
            results.textContent = 'Running reflow analysis...\n\n';

            setTimeout(() => {
                const container = document.createElement('div');
                container.style.position = 'relative';
                document.body.appendChild(container);

                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip-auto';
                tooltip.textContent = 'Test tooltip';
                container.appendChild(tooltip);

                let reflowCount = 0;
                const originalOffsetWidth = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetWidth').get;

                Object.defineProperty(HTMLElement.prototype, 'offsetWidth', {
                    get: function() {
                        if (this === tooltip) reflowCount++;
                        return originalOffsetWidth.call(this);
                    }
                });

                // Test different scenarios
                const scenarios = [
                    {
                        name: 'Show/Hide without width read',
                        test: () => {
                            tooltip.classList.add('tooltip-visible');
                            tooltip.classList.remove('tooltip-visible');
                        }
                    },
                    {
                        name: 'Show/Hide with width read',
                        test: () => {
                            tooltip.classList.add('tooltip-visible');
                            const w = tooltip.offsetWidth;
                            tooltip.classList.remove('tooltip-visible');
                        }
                    },
                    {
                        name: 'Content change',
                        test: () => {
                            tooltip.textContent = 'New text';
                            const w = tooltip.offsetWidth;
                        }
                    }
                ];

                let output = 'REFLOW ANALYSIS\n\n';

                scenarios.forEach(scenario => {
                    reflowCount = 0;
                    const start = performance.now();
                    for (let i = 0; i < 100; i++) {
                        scenario.test();
                    }
                    const duration = performance.now() - start;

                    output += `${scenario.name}:\n`;
                    output += `  Reflows: ${reflowCount} (${(reflowCount/100).toFixed(2)} per iteration)\n`;
                    output += `  Time: ${duration.toFixed(2)}ms (${(duration/100).toFixed(4)}ms per iteration)\n\n`;
                });

                document.body.removeChild(container);
                results.textContent = output;
            }, 100);
        }

        // Test 3: GPU Acceleration
        function runGPUTest() {
            const results = document.getElementById('gpu-results');
            results.style.display = 'block';
            results.textContent = 'Running GPU acceleration tests...\n\n';

            setTimeout(() => {
                const testCases = [
                    {
                        name: 'Standard (no GPU)',
                        css: {
                            transform: 'translateX(-50%)',
                            transition: 'opacity 0.2s'
                        }
                    },
                    {
                        name: 'GPU (translateZ)',
                        css: {
                            transform: 'translateX(-50%) translateZ(0)',
                            transition: 'opacity 0.2s'
                        }
                    },
                    {
                        name: 'GPU (will-change)',
                        css: {
                            transform: 'translateX(-50%)',
                            transition: 'opacity 0.2s',
                            willChange: 'opacity, transform'
                        }
                    },
                    {
                        name: 'GPU (full optimization)',
                        css: {
                            transform: 'translateX(-50%) translateZ(0)',
                            transition: 'opacity 0.2s',
                            willChange: 'opacity',
                            backfaceVisibility: 'hidden'
                        }
                    }
                ];

                const container = document.createElement('div');
                container.style.position = 'relative';
                container.style.width = '100px';
                container.style.height = '100px';
                document.body.appendChild(container);

                let output = 'GPU ACCELERATION IMPACT\n\n';

                testCases.forEach(testCase => {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip-auto';
                    tooltip.textContent = 'GPU test tooltip';
                    Object.assign(tooltip.style, testCase.css);
                    container.appendChild(tooltip);

                    const result = measurePerformance(() => {
                        tooltip.style.opacity = '1';
                        tooltip.style.opacity = '0';
                    }, 500);

                    output += `${testCase.name}:\n`;
                    output += `  Average: ${result.avg.toFixed(4)}ms\n`;
                    output += `  P95: ${result.p95.toFixed(4)}ms\n\n`;

                    container.removeChild(tooltip);
                });

                document.body.removeChild(container);
                results.textContent = output;
            }, 100);
        }

        // Test 4: Text Measurement
        function runTextMeasurementTest() {
            const results = document.getElementById('text-results');
            results.style.display = 'block';
            results.textContent = 'Running text measurement tests...\n\n';

            setTimeout(() => {
                const texts = [
                    'Short',
                    'Medium length tooltip',
                    'Very long tooltip text that might wrap'
                ];

                let output = 'TEXT MEASUREMENT PERFORMANCE\n\n';

                // Method 1: Canvas API
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

                const canvasResult = measurePerformance(() => {
                    texts.forEach(text => {
                        const metrics = ctx.measureText(text);
                        const width = metrics.width;
                    });
                }, 1000);

                output += 'Canvas API:\n';
                output += `  Average: ${canvasResult.avg.toFixed(4)}ms\n`;
                output += `  P95: ${canvasResult.p95.toFixed(4)}ms\n\n`;

                // Method 2: DOM measurement
                const testDiv = document.createElement('div');
                testDiv.style.position = 'absolute';
                testDiv.style.visibility = 'hidden';
                testDiv.style.whiteSpace = 'nowrap';
                testDiv.style.font = '14px -apple-system';
                document.body.appendChild(testDiv);

                const domResult = measurePerformance(() => {
                    texts.forEach(text => {
                        testDiv.textContent = text;
                        const width = testDiv.offsetWidth;
                    });
                }, 1000);

                output += 'DOM Measurement:\n';
                output += `  Average: ${domResult.avg.toFixed(4)}ms\n`;
                output += `  P95: ${domResult.p95.toFixed(4)}ms\n\n`;

                document.body.removeChild(testDiv);

                // Method 3: Cached measurements
                const cache = new Map();
                texts.forEach(text => {
                    ctx.font = '14px -apple-system';
                    cache.set(text, ctx.measureText(text).width);
                });

                const cachedResult = measurePerformance(() => {
                    texts.forEach(text => {
                        const width = cache.get(text);
                    });
                }, 1000);

                output += 'Cached Measurements:\n';
                output += `  Average: ${cachedResult.avg.toFixed(4)}ms\n`;
                output += `  P95: ${cachedResult.p95.toFixed(4)}ms\n\n`;

                const speedup = (domResult.avg / cachedResult.avg).toFixed(1);
                output += `RECOMMENDATION: Cached measurements are ${speedup}x faster than DOM\n`;
                output += `Canvas API is ${(domResult.avg / canvasResult.avg).toFixed(1)}x faster than DOM\n`;

                results.textContent = output;
            }, 100);
        }

        // Test 5: Mobile Simulation
        function runMobileTest() {
            const results = document.getElementById('mobile-results');
            results.style.display = 'block';
            results.textContent = 'Running mobile simulation...\n\n';

            setTimeout(() => {
                let output = 'MOBILE PERFORMANCE SIMULATION\n\n';

                // Simulate viewport constraints
                const container = document.createElement('div');
                container.style.position = 'relative';
                container.style.width = '375px'; // iPhone width
                document.body.appendChild(container);

                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip-auto';
                tooltip.textContent = 'Mobile tooltip with viewport constraints';
                container.appendChild(tooltip);

                // Test with viewport units
                const viewportResult = measurePerformance(() => {
                    tooltip.style.maxWidth = 'min(500px, 90vw)';
                    const width = tooltip.offsetWidth;
                }, 500);

                output += 'Viewport Unit Calculation:\n';
                output += `  Average: ${viewportResult.avg.toFixed(4)}ms\n`;
                output += `  P95: ${viewportResult.p95.toFixed(4)}ms\n\n`;

                // Test fixed width
                const fixedResult = measurePerformance(() => {
                    tooltip.style.maxWidth = '337px'; // 90% of 375px
                    const width = tooltip.offsetWidth;
                }, 500);

                output += 'Fixed Width:\n';
                output += `  Average: ${fixedResult.avg.toFixed(4)}ms\n`;
                output += `  P95: ${fixedResult.p95.toFixed(4)}ms\n\n`;

                // Touch event simulation
                let touchCount = 0;
                const touchHandler = () => {
                    tooltip.classList.add('tooltip-visible');
                    touchCount++;
                    setTimeout(() => tooltip.classList.remove('tooltip-visible'), 100);
                };

                const touchStart = performance.now();
                for (let i = 0; i < 100; i++) {
                    touchHandler();
                }
                const touchDuration = performance.now() - touchStart;

                output += 'Touch Event Handling:\n';
                output += `  100 events: ${touchDuration.toFixed(2)}ms\n`;
                output += `  Per event: ${(touchDuration/100).toFixed(4)}ms\n\n`;

                document.body.removeChild(container);

                output += 'MOBILE RECOMMENDATIONS:\n';
                output += '  - Use fixed maxWidth for mobile (avoid vw calculations)\n';
                output += '  - Debounce touch events for better performance\n';
                output += '  - Consider tap-to-show instead of hover\n';

                results.textContent = output;
            }, 100);
        }

        // Test 6: Memory Impact
        function runMemoryTest() {
            const results = document.getElementById('memory-results');
            results.style.display = 'block';

            if (!performance.memory) {
                results.textContent = 'Memory API not available in this browser.\nTry Chrome with --enable-precise-memory-info flag.';
                return;
            }

            results.textContent = 'Running memory tests...\n\n';

            setTimeout(() => {
                const container = document.createElement('div');
                container.style.position = 'relative';
                document.body.appendChild(container);

                // Measure baseline
                const baseline = performance.memory.usedJSHeapSize;

                // Create 100 tooltips
                const tooltips = [];
                for (let i = 0; i < 100; i++) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip-optimized';
                    tooltip.textContent = `Tooltip ${i}: This is a sample tooltip text`;
                    container.appendChild(tooltip);
                    tooltips.push(tooltip);
                }

                const withTooltips = performance.memory.usedJSHeapSize;
                const tooltipMemory = withTooltips - baseline;

                // Cleanup
                tooltips.forEach(t => container.removeChild(t));
                document.body.removeChild(container);

                let output = 'MEMORY IMPACT ANALYSIS\n\n';
                output += `Baseline: ${(baseline / 1024 / 1024).toFixed(2)} MB\n`;
                output += `With 100 tooltips: ${(withTooltips / 1024 / 1024).toFixed(2)} MB\n`;
                output += `Per tooltip: ${(tooltipMemory / 100 / 1024).toFixed(2)} KB\n\n`;

                output += 'MEMORY RECOMMENDATIONS:\n';
                output += '  - Reuse single tooltip element when possible\n';
                output += '  - Remove tooltips from DOM when not in use\n';
                output += `  - ${tooltipMemory / 100 < 1024 ? 'Low' : 'High'} memory impact per tooltip\n`;

                results.textContent = output;
            }, 100);
        }

        // Create interactive test points
        function createTestPoints() {
            const container = document.getElementById('test-points');
            const approaches = [
                { name: 'Auto', className: 'tooltip-auto' },
                { name: 'Fit', className: 'tooltip-fit-content' },
                { name: 'Min', className: 'tooltip-min-content' },
                { name: 'GPU', className: 'tooltip-optimized' }
            ];

            approaches.forEach((approach, index) => {
                const point = document.createElement('div');
                point.className = 'point';
                point.title = approach.name;

                const tooltip = document.createElement('div');
                tooltip.className = approach.className;
                tooltip.textContent = `${approach.name}: Hover to test performance`;
                point.appendChild(tooltip);

                point.addEventListener('mouseenter', () => {
                    const start = performance.now();
                    tooltip.classList.add('tooltip-visible');
                    const duration = performance.now() - start;
                    updateLiveStats(approach.name, duration);
                });

                point.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('tooltip-visible');
                });

                container.appendChild(point);
            });
        }

        // Live performance monitoring
        function updateLiveStats(approach, duration) {
            const stats = document.getElementById('live-stats');
            stats.innerHTML = `
                <strong>Last Hover:</strong><br>
                Approach: ${approach}<br>
                Duration: ${duration.toFixed(4)}ms<br>
                FPS: ${(1000 / duration).toFixed(0)}
            `;
        }

        // Initialize
        createTestPoints();

        // Run all tests button
        function runAllTests() {
            runCSSApproachTest();
            setTimeout(() => runReflowTest(), 1000);
            setTimeout(() => runGPUTest(), 2000);
            setTimeout(() => runTextMeasurementTest(), 3000);
            setTimeout(() => runMobileTest(), 4000);
            setTimeout(() => runMemoryTest(), 5000);
        }
    </script>
</body>
</html>
